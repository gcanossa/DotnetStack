//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace GKit.RENTRI.Stubs.VidimazioneFormulari
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VidimazioneFormulariStub : BaseClient
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public VidimazioneFormulariStub(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "https://api.rentri.gov.it/vidimazione-formulari/v1.0";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Elenco blocchi
        /// </summary>
        /// <remarks>
        /// Restituisce l'elenco dei blocchi del soggetto specificato.
        /// <br/>
        /// <br/>Se si indica anche il numero iscrizione unit√† locale, vengono restituiti solo i blocchi dell'unit√† locale specificata.
        /// <br/>
        /// <br/>La creazione dei blocchi √® possibile solo nell'area web Operatori, tramite la funzionalit√† Interoperabilit√†/Gestione blocchi virtuali dei FIR.
        /// <br/>
        /// <br/>Nell'ambiente DEMO √® possibile creare al massimo 100 blocchi per operatore.
        /// <br/>
        /// <br/>Nell'ambiente PRODUZIONE √® possibile creare al massimo 500 blocchi per operatore.
        /// </remarks>
        /// <param name="identificativo">Codice fiscale del soggetto per il quale recuperare i blocchi</param>
        /// <param name="num_iscr_sito">Numero iscrizione unit√† locale per il quale recuperare i blocchi</param>
        /// <param name="codice_blocco">Codice del singolo blocco da recuperare</param>
        /// <param name="anche_disattivi">Parametro booleano per recuperare anche i blocchi disattivati</param>
        /// <param name="paging_Page">Valore per l'header Paging-Page.</param>
        /// <param name="paging_PageSize">Valore per l'header Paging-PageSize.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BloccoModel>> AnonymousAllAsync(string identificativo, string num_iscr_sito, string codice_blocco, bool? anche_disattivi, int? paging_Page, int? paging_PageSize)
        {
            return AnonymousAllAsync(identificativo, num_iscr_sito, codice_blocco, anche_disattivi, paging_Page, paging_PageSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Elenco blocchi
        /// </summary>
        /// <remarks>
        /// Restituisce l'elenco dei blocchi del soggetto specificato.
        /// <br/>
        /// <br/>Se si indica anche il numero iscrizione unit√† locale, vengono restituiti solo i blocchi dell'unit√† locale specificata.
        /// <br/>
        /// <br/>La creazione dei blocchi √® possibile solo nell'area web Operatori, tramite la funzionalit√† Interoperabilit√†/Gestione blocchi virtuali dei FIR.
        /// <br/>
        /// <br/>Nell'ambiente DEMO √® possibile creare al massimo 100 blocchi per operatore.
        /// <br/>
        /// <br/>Nell'ambiente PRODUZIONE √® possibile creare al massimo 500 blocchi per operatore.
        /// </remarks>
        /// <param name="identificativo">Codice fiscale del soggetto per il quale recuperare i blocchi</param>
        /// <param name="num_iscr_sito">Numero iscrizione unit√† locale per il quale recuperare i blocchi</param>
        /// <param name="codice_blocco">Codice del singolo blocco da recuperare</param>
        /// <param name="anche_disattivi">Parametro booleano per recuperare anche i blocchi disattivati</param>
        /// <param name="paging_Page">Valore per l'header Paging-Page.</param>
        /// <param name="paging_PageSize">Valore per l'header Paging-PageSize.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<BloccoModel>> AnonymousAllAsync(string identificativo, string num_iscr_sito, string codice_blocco, bool? anche_disattivi, int? paging_Page, int? paging_PageSize, System.Threading.CancellationToken cancellationToken)
        {
            if (identificativo == null)
                throw new System.ArgumentNullException("identificativo");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (paging_Page != null)
                        request_.Headers.TryAddWithoutValidation("Paging-Page", ConvertToString(paging_Page, System.Globalization.CultureInfo.InvariantCulture));

                    if (paging_PageSize != null)
                        request_.Headers.TryAddWithoutValidation("Paging-PageSize", ConvertToString(paging_PageSize, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: ""
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("identificativo")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(identificativo, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (num_iscr_sito != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("num_iscr_sito")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(num_iscr_sito, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (codice_blocco != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("codice_blocco")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(codice_blocco, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (anche_disattivi != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("anche_disattivi")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(anche_disattivi, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<BloccoModel>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Forbidden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Elenco FIR vidimati
        /// </summary>
        /// <remarks>
        /// Restituisce l'elenco dei FIR vidimati per il blocco specificato.
        /// </remarks>
        /// <param name="codice_blocco">Codice del blocco per il quale si richiede l'elenco delle vidimazioni FIR.</param>
        /// <param name="progressivo_iniziale">Progressivo iniziale a partire dal quale restituire l'elenco delle vidimazioni FIR.</param>
        /// <param name="progressivo_finale">Progressivo finale fino al quale restituire l'elenco dei numeri FIR.</param>
        /// <param name="paging_Page">Valore per l'header Paging-Page.</param>
        /// <param name="paging_PageSize">Valore per l'header Paging-PageSize.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<EfirModel>> AnonymousAll2Async(string codice_blocco, int? progressivo_iniziale, int? progressivo_finale, int? paging_Page, int? paging_PageSize)
        {
            return AnonymousAll2Async(codice_blocco, progressivo_iniziale, progressivo_finale, paging_Page, paging_PageSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Elenco FIR vidimati
        /// </summary>
        /// <remarks>
        /// Restituisce l'elenco dei FIR vidimati per il blocco specificato.
        /// </remarks>
        /// <param name="codice_blocco">Codice del blocco per il quale si richiede l'elenco delle vidimazioni FIR.</param>
        /// <param name="progressivo_iniziale">Progressivo iniziale a partire dal quale restituire l'elenco delle vidimazioni FIR.</param>
        /// <param name="progressivo_finale">Progressivo finale fino al quale restituire l'elenco dei numeri FIR.</param>
        /// <param name="paging_Page">Valore per l'header Paging-Page.</param>
        /// <param name="paging_PageSize">Valore per l'header Paging-PageSize.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<EfirModel>> AnonymousAll2Async(string codice_blocco, int? progressivo_iniziale, int? progressivo_finale, int? paging_Page, int? paging_PageSize, System.Threading.CancellationToken cancellationToken)
        {
            if (codice_blocco == null)
                throw new System.ArgumentNullException("codice_blocco");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (paging_Page != null)
                        request_.Headers.TryAddWithoutValidation("Paging-Page", ConvertToString(paging_Page, System.Globalization.CultureInfo.InvariantCulture));

                    if (paging_PageSize != null)
                        request_.Headers.TryAddWithoutValidation("Paging-PageSize", ConvertToString(paging_PageSize, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{codice_blocco}"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(codice_blocco, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (progressivo_iniziale != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("progressivo_iniziale")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(progressivo_iniziale, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (progressivo_finale != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("progressivo_finale")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(progressivo_finale, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<EfirModel>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Forbidden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// üîÅ[ASYNC] Vidimazione nuovo FIR
        /// </summary>
        /// <remarks>
        /// Acquisisce la richiesta di vidimazione di un nuovo FIR per il blocco specificato.
        /// <br/>
        /// <br/>Il servizio di vidimazione √® soggetto a limiti giornalieri in funzione del tipo di blocco per cui si richiede la vidimazione.
        /// <br/>
        /// <br/>Nell'ambiente DEMO le richieste giornaliere effettuabili per operatore sono 500 sull'insieme dei blocchi non associati a unit√† locali e 500 sull'insieme dei blocchi associati ad una stessa unit√† locale.
        /// <br/>
        /// <br/>Nell'ambiente PRODUZIONE le richieste giornaliere effettuabili per operatore sono 1000 sull'insieme dei blocchi non associati a unit√† locali e 1000 sull'insieme dei blocchi associati ad una stessa unit√† locale.
        /// <br/>&lt;br/&gt;Se viene specificato un URL nell'header &lt;i&gt;X-ReplyTo&lt;/i&gt;, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.
        /// </remarks>
        /// <param name="codice_blocco">Codice blocco dal nuovo FIR da vidimare.</param>
        /// <param name="x_ReplyTo">URL di callback alla quale verr√† inviata la notifica di fine elaborazione.</param>
        /// <returns>Richiesta accettata.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<TransazioneModel> AnonymousPOSTAsync(string codice_blocco, string x_ReplyTo)
        {
            return AnonymousPOSTAsync(codice_blocco, x_ReplyTo, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// üîÅ[ASYNC] Vidimazione nuovo FIR
        /// </summary>
        /// <remarks>
        /// Acquisisce la richiesta di vidimazione di un nuovo FIR per il blocco specificato.
        /// <br/>
        /// <br/>Il servizio di vidimazione √® soggetto a limiti giornalieri in funzione del tipo di blocco per cui si richiede la vidimazione.
        /// <br/>
        /// <br/>Nell'ambiente DEMO le richieste giornaliere effettuabili per operatore sono 500 sull'insieme dei blocchi non associati a unit√† locali e 500 sull'insieme dei blocchi associati ad una stessa unit√† locale.
        /// <br/>
        /// <br/>Nell'ambiente PRODUZIONE le richieste giornaliere effettuabili per operatore sono 1000 sull'insieme dei blocchi non associati a unit√† locali e 1000 sull'insieme dei blocchi associati ad una stessa unit√† locale.
        /// <br/>&lt;br/&gt;Se viene specificato un URL nell'header &lt;i&gt;X-ReplyTo&lt;/i&gt;, al termine dell'elaborazione dei dati, il fruitore ricever√† una notifica con l'esito dell'elaborazione all'URL specificato.
        /// </remarks>
        /// <param name="codice_blocco">Codice blocco dal nuovo FIR da vidimare.</param>
        /// <param name="x_ReplyTo">URL di callback alla quale verr√† inviata la notifica di fine elaborazione.</param>
        /// <returns>Richiesta accettata.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TransazioneModel> AnonymousPOSTAsync(string codice_blocco, string x_ReplyTo, System.Threading.CancellationToken cancellationToken)
        {
            if (codice_blocco == null)
                throw new System.ArgumentNullException("codice_blocco");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_ReplyTo != null)
                        request_.Headers.TryAddWithoutValidation("X-ReplyTo", ConvertToString(x_ReplyTo, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{codice_blocco}"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(codice_blocco, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TransazioneModel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Dettaglio degli errori di validazione in caso di modello dati non valido.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Codice blocco trovato.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Dati di vidimazione FIR
        /// </summary>
        /// <remarks>
        /// Restituisce tutti i dati relativi alla vidimazione del FIR.
        /// </remarks>
        /// <param name="codice_blocco">Codice del blocco a cui appartiene il FIR per cui si richiedono i dati.</param>
        /// <param name="progressivo">Numero progressivo del FIR per cui si richiedono i dati.</param>
        /// <param name="xml">Se valorizzato a true nella struttura dati restituita viene valorizzato anche la propriet√† xml contenente il file XML firmato che rappresenta la validazione.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EfirModel> AnonymousGETAsync(string codice_blocco, string progressivo, bool? xml)
        {
            return AnonymousGETAsync(codice_blocco, progressivo, xml, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Dati di vidimazione FIR
        /// </summary>
        /// <remarks>
        /// Restituisce tutti i dati relativi alla vidimazione del FIR.
        /// </remarks>
        /// <param name="codice_blocco">Codice del blocco a cui appartiene il FIR per cui si richiedono i dati.</param>
        /// <param name="progressivo">Numero progressivo del FIR per cui si richiedono i dati.</param>
        /// <param name="xml">Se valorizzato a true nella struttura dati restituita viene valorizzato anche la propriet√† xml contenente il file XML firmato che rappresenta la validazione.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EfirModel> AnonymousGETAsync(string codice_blocco, string progressivo, bool? xml, System.Threading.CancellationToken cancellationToken)
        {
            if (codice_blocco == null)
                throw new System.ArgumentNullException("codice_blocco");

            if (progressivo == null)
                throw new System.ArgumentNullException("progressivo");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{codice_blocco}/{progressivo}"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(codice_blocco, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(progressivo, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (xml != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("xml")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(xml, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EfirModel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Forbidden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Annulla vidimazione FIR
        /// </summary>
        /// <remarks>
        /// Imposta ad annullata la vidimazione del FIR specificato.
        /// <br/>
        /// <br/>Le condizioni affinch√© l'annullamento del numero FIR venga eseguito sono:
        /// <br/>&lt;ul&gt;&lt;li&gt;Non deve risultare presente tra quelli in compilazione nei servizi di supporto&lt;/li&gt;&lt;li&gt;Non deve risultare presente tra le copie cartacee dei FIR riconsegnate dal trasportatore&lt;/li&gt;&lt;li&gt;Non deve risultare presente tra le copie digitali dei FIR riconsegnate dal destinatario&lt;/li&gt;&lt;li&gt;Non deve risultare alcuna trasmissione dati FIR effettuata da alcun soggetto (per rifiuti pericolosi)&lt;/li&gt;&lt;/ul&gt;
        /// </remarks>
        /// <param name="codice_blocco">Codice del blocco a cui appartiene il FIR per cui si richiede l'annullamento.</param>
        /// <param name="progressivo">Numero progressivo del FIR per cui si richiede l'annullamento.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task AnnullaAsync(string codice_blocco, string progressivo)
        {
            return AnnullaAsync(codice_blocco, progressivo, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Annulla vidimazione FIR
        /// </summary>
        /// <remarks>
        /// Imposta ad annullata la vidimazione del FIR specificato.
        /// <br/>
        /// <br/>Le condizioni affinch√© l'annullamento del numero FIR venga eseguito sono:
        /// <br/>&lt;ul&gt;&lt;li&gt;Non deve risultare presente tra quelli in compilazione nei servizi di supporto&lt;/li&gt;&lt;li&gt;Non deve risultare presente tra le copie cartacee dei FIR riconsegnate dal trasportatore&lt;/li&gt;&lt;li&gt;Non deve risultare presente tra le copie digitali dei FIR riconsegnate dal destinatario&lt;/li&gt;&lt;li&gt;Non deve risultare alcuna trasmissione dati FIR effettuata da alcun soggetto (per rifiuti pericolosi)&lt;/li&gt;&lt;/ul&gt;
        /// </remarks>
        /// <param name="codice_blocco">Codice del blocco a cui appartiene il FIR per cui si richiede l'annullamento.</param>
        /// <param name="progressivo">Numero progressivo del FIR per cui si richiede l'annullamento.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task AnnullaAsync(string codice_blocco, string progressivo, System.Threading.CancellationToken cancellationToken)
        {
            if (codice_blocco == null)
                throw new System.ArgumentNullException("codice_blocco");

            if (progressivo == null)
                throw new System.ArgumentNullException("progressivo");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{codice_blocco}/{progressivo}/annulla"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(codice_blocco, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(progressivo, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/annulla");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Forbidden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Not Found", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Modello FIR PDF
        /// </summary>
        /// <remarks>
        /// Restituisce un file PDF firmato precompilato con i dati di vidimazione del FIR da riportare nella stampa.
        /// </remarks>
        /// <param name="codice_blocco">Codice del blocco a cui appartiene il FIR per cui si richiedono i dati.</param>
        /// <param name="progressivo">Numero progressivo del FIR per cui si richiedono i dati.</param>
        /// <param name="senza_numero_pagina">Se valorizzato a true il numero di pagina non √® presente.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DownloadableBaseResponse> PdfAsync(string codice_blocco, string progressivo, bool? senza_numero_pagina)
        {
            return PdfAsync(codice_blocco, progressivo, senza_numero_pagina, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Modello FIR PDF
        /// </summary>
        /// <remarks>
        /// Restituisce un file PDF firmato precompilato con i dati di vidimazione del FIR da riportare nella stampa.
        /// </remarks>
        /// <param name="codice_blocco">Codice del blocco a cui appartiene il FIR per cui si richiedono i dati.</param>
        /// <param name="progressivo">Numero progressivo del FIR per cui si richiedono i dati.</param>
        /// <param name="senza_numero_pagina">Se valorizzato a true il numero di pagina non √® presente.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DownloadableBaseResponse> PdfAsync(string codice_blocco, string progressivo, bool? senza_numero_pagina, System.Threading.CancellationToken cancellationToken)
        {
            if (codice_blocco == null)
                throw new System.ArgumentNullException("codice_blocco");

            if (progressivo == null)
                throw new System.ArgumentNullException("progressivo");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{codice_blocco}/{progressivo}/pdf"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(codice_blocco, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(progressivo, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/pdf");
                    urlBuilder_.Append('?');
                    if (senza_numero_pagina != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("senza_numero_pagina")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(senza_numero_pagina, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DownloadableBaseResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Forbidden", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Not Found", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Esito transazione
        /// </summary>
        /// <remarks>
        /// Ottiene l'esito dell'elaborazione di una richiesta di vidimazione FIR.
        /// </remarks>
        /// <param name="transazione_id">Id della richiesta.</param>
        /// <returns>Esito dell'elaborazione con eventuali errori.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EsitoVidimazioneModel> ResultAsync(System.Guid transazione_id)
        {
            return ResultAsync(transazione_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Esito transazione
        /// </summary>
        /// <remarks>
        /// Ottiene l'esito dell'elaborazione di una richiesta di vidimazione FIR.
        /// </remarks>
        /// <param name="transazione_id">Id della richiesta.</param>
        /// <returns>Esito dell'elaborazione con eventuali errori.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EsitoVidimazioneModel> ResultAsync(System.Guid transazione_id, System.Threading.CancellationToken cancellationToken)
        {
            if (transazione_id == null)
                throw new System.ArgumentNullException("transazione_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{transazione_id}/result"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(transazione_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/result");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EsitoVidimazioneModel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Richiesta non ancora elaborata.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non trovata.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Stato transazione
        /// </summary>
        /// <remarks>
        /// Ottiene lo stato di elaborazione di una richiesta di vidimazione FIR.
        /// </remarks>
        /// <param name="transazione_id">Id della richiesta.</param>
        /// <returns>Richiesta non ancora elaborata.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task StatusAsync(System.Guid transazione_id)
        {
            return StatusAsync(transazione_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Stato transazione
        /// </summary>
        /// <remarks>
        /// Ottiene lo stato di elaborazione di una richiesta di vidimazione FIR.
        /// </remarks>
        /// <param name="transazione_id">Id della richiesta.</param>
        /// <returns>Richiesta non ancora elaborata.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task StatusAsync(System.Guid transazione_id, System.Threading.CancellationToken cancellationToken)
        {
            if (transazione_id == null)
                throw new System.ArgumentNullException("transazione_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "{transazione_id}/status"
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(transazione_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/status");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 303)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("La richiesta \u00e8 stata elaborata e l\'URL per il recupero dell\'esito si trova nell\'header Location.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non trovata.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Certificato di firma
        /// </summary>
        /// <remarks>
        /// Recupera il certificato di firma della vidimazione con l'identificativo specificato.
        /// </remarks>
        /// <param name="certificato_id">Stringa identificativa del certificato.</param>
        /// <returns>Certificato recuperato.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CertificateModel>> CertificatiAsync(string certificato_id)
        {
            return CertificatiAsync(certificato_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Certificato di firma
        /// </summary>
        /// <remarks>
        /// Recupera il certificato di firma della vidimazione con l'identificativo specificato.
        /// </remarks>
        /// <param name="certificato_id">Stringa identificativa del certificato.</param>
        /// <returns>Certificato recuperato.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<CertificateModel>> CertificatiAsync(string certificato_id, System.Threading.CancellationToken cancellationToken)
        {
            if (certificato_id == null)
                throw new System.ArgumentNullException("certificato_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "certificati/{certificato_id}"
                    urlBuilder_.Append("certificati/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(certificato_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<CertificateModel>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Certificato non trovato.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Stato API
        /// </summary>
        /// <remarks>
        /// Verifica dello stato dell'API.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<StatusResponse> Status2Async()
        {
            return Status2Async(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Stato API
        /// </summary>
        /// <remarks>
        /// Verifica dello stato dell'API.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<StatusResponse> Status2Async(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "status"
                    urlBuilder_.Append("status");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Verifica numero FIR
        /// </summary>
        /// <remarks>
        /// Verifica l'esistenza del numero FIR.
        /// </remarks>
        /// <param name="numero_fir">Numero del FIR</param>
        /// <returns>Dettaglio dei dati di vidimazione</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EfirPublicModel> VerificaAsync(string numero_fir)
        {
            return VerificaAsync(numero_fir, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Verifica numero FIR
        /// </summary>
        /// <remarks>
        /// Verifica l'esistenza del numero FIR.
        /// </remarks>
        /// <param name="numero_fir">Numero del FIR</param>
        /// <returns>Dettaglio dei dati di vidimazione</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EfirPublicModel> VerificaAsync(string numero_fir, System.Threading.CancellationToken cancellationToken)
        {
            if (numero_fir == null)
                throw new System.ArgumentNullException("numero_fir");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "verifica/{numero_fir}"
                    urlBuilder_.Append("verifica/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(numero_fir, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EfirPublicModel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Dettaglio degli errori di validazione in caso di modello dati non valido.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza)", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field_ = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field_ != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field_, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BloccoModel
    {

        /// <summary>
        /// Stato di attivazione del blocco virtuale
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("disattivo")]
        public bool Disattivo { get; set; }

        /// <summary>
        /// Codice fiscale del soggetto a cui √® associato il blocco
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo_soggetto")]
        [System.ComponentModel.DataAnnotations.StringLength(255)]
        public string Identificativo_soggetto { get; set; }

        /// <summary>
        /// Denominazione del soggetto a cui √® associato il blocco
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("denominazione_soggetto")]
        public string Denominazione_soggetto { get; set; }

        /// <summary>
        /// Codice del blocco virtuale
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("codice_blocco")]
        public string Codice_blocco { get; set; }

        /// <summary>
        /// Descrizione del blocco virtuale
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("descrizione")]
        public string Descrizione { get; set; }

        /// <summary>
        /// Codice fiscale dell'utente che ha creato il blocco
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("codice_fiscale_utente")]
        public string Codice_fiscale_utente { get; set; }

        /// <summary>
        /// Formato ISO 8601 UTC
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_creazione")]
        public System.DateTimeOffset? Data_creazione { get; set; }

        /// <summary>
        /// Contatore dei FIR vidimati sul blocco virtuale
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("numero_fir_vidimati")]
        public int Numero_fir_vidimati { get; set; }

        /// <summary>
        /// Formato ISO 8601 UTC
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_ultimo_utilizzo")]
        public System.DateTimeOffset? Data_ultimo_utilizzo { get; set; }

        /// <summary>
        /// Numero di iscrizione dell'unit√† locale a cui √® associato il blocco virtuale
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("num_iscr_sito")]
        public string Num_iscr_sito { get; set; }

        /// <summary>
        /// Indirizzo dell'unit√† locale a cui √® associato il blocco virtuale
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("indirizzo")]
        public string Indirizzo { get; set; }

        /// <summary>
        /// Numero civico dell'indirizzo dell'unit√† locale a cui √® associato il blocco virtuale
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("civico")]
        public string Civico { get; set; }

        /// <summary>
        /// Codice ISTAT del comune dell'unit√† locale a cui √® associato il blocco virtuale
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("comune_id")]
        public string Comune_id { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CertificateModel
    {

        [System.Text.Json.Serialization.JsonPropertyName("certificato")]
        public string Certificato { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("subject")]
        public string Subject { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DownloadableBaseResponse
    {

        /// <summary>
        /// Nome del file
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("nome_file")]
        public string Nome_file { get; set; }

        /// <summary>
        /// Tipo MIME del file
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("mime")]
        public string Mime { get; set; }

        /// <summary>
        /// Contenuto del file
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("content")]
        public byte[] Content { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EfirModel
    {

        /// <summary>
        /// Codice fiscale dell'utente che ha richiesto la vidimazione del FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_richiesta")]
        public string Utente_richiesta { get; set; }

        /// <summary>
        /// Denominazione dell'utente che ha richiesto la vidimazione del FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("denominazione_utente_richiesta")]
        public string Denominazione_utente_richiesta { get; set; }

        /// <summary>
        /// Autore dell'eventuale annullamento del FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_annullamento")]
        public string Utente_annullamento { get; set; }

        /// <summary>
        /// Indica se il FIR sia stato generato attraverso il sistema di interoperabilit√† (API) o attraverso il portale
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("origine")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<Origine>))]
        public Origine? Origine { get; set; }

        /// <summary>
        /// Xml firmato del FIR in fase di vidimazione. Il dato √® eventualmente restituito dalla richiesta dei dati di vidimazione FIR.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("xml")]
        public string Xml { get; set; }

        /// <summary>
        /// Numero progressivo del FIR all'interno del blocco di appartenenza
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("progressivo")]
        public int Progressivo { get; set; }

        /// <summary>
        /// Codice seriale del FIR contenente la concatenazione del codice di blocco, il progressivo ed il checksum
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("numero_fir")]
        public string Numero_fir { get; set; }

        /// <summary>
        /// Array di byte contenuto nel codice QR Code che consente di verificare la validit√† del FIR.
        /// <br/>L'array di byte viene restituito codificato in Base64 dall'endpoint in una propriet√† JSON di tipo stringa.
        /// <br/>Il formato del contenuto del QR Code √® conforme allo standard CBOR Object Signing and Encryption (COSE), RFC 8152.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("qr_code_bytes")]
        public byte[] Qr_code_bytes { get; set; }

        /// <summary>
        /// Caratteri alfanumerici utilizzati come codice univoco associato in sede di vidimazione al numero FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("check_sum")]
        public string Check_sum { get; set; }

        /// <summary>
        /// Data e ora in cui √® stata effettuata la richiesta di vidimazione del FIR (formato ISO 8601 UTC)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_richiesta")]
        public System.DateTimeOffset Data_richiesta { get; set; }

        /// <summary>
        /// Ragione sociale del soggetto per conto del quale √® stato vidimato il FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("denominazione_soggetto")]
        public string Denominazione_soggetto { get; set; }

        /// <summary>
        /// Codice fiscale del soggetto per conto del quale √® stato vidimato il FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("codice_fiscale_soggetto")]
        public string Codice_fiscale_soggetto { get; set; }

        /// <summary>
        /// Numero di iscrizione dell'unit√† locale del soggetto per conto del quale √® stato vidimato il FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("num_iscr_sito")]
        public string Num_iscr_sito { get; set; }

        /// <summary>
        /// Codice del blocco a cui appartiene il FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("codice_blocco")]
        public string Codice_blocco { get; set; }

        /// <summary>
        /// Nome della CCIAA di competenza del FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("cciaa_nome")]
        public string Cciaa_nome { get; set; }

        /// <summary>
        /// Stato di annullamento del FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("is_annullato")]
        public bool? Is_annullato { get; set; }

        /// <summary>
        /// Data dell'eventuale annullamento del FIR (formato ISO 8601 UTC)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_annullamento")]
        public System.DateTimeOffset? Data_annullamento { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EfirPublicModel
    {

        /// <summary>
        /// Numero progressivo del FIR all'interno del blocco di appartenenza
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("progressivo")]
        public int Progressivo { get; set; }

        /// <summary>
        /// Codice seriale del FIR contenente la concatenazione del codice di blocco, il progressivo ed il checksum
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("numero_fir")]
        public string Numero_fir { get; set; }

        /// <summary>
        /// Array di byte contenuto nel codice QR Code che consente di verificare la validit√† del FIR.
        /// <br/>L'array di byte viene restituito codificato in Base64 dall'endpoint in una propriet√† JSON di tipo stringa.
        /// <br/>Il formato del contenuto del QR Code √® conforme allo standard CBOR Object Signing and Encryption (COSE), RFC 8152.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("qr_code_bytes")]
        public byte[] Qr_code_bytes { get; set; }

        /// <summary>
        /// Caratteri alfanumerici utilizzati come codice univoco associato in sede di vidimazione al numero FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("check_sum")]
        public string Check_sum { get; set; }

        /// <summary>
        /// Data e ora in cui √® stata effettuata la richiesta di vidimazione del FIR (formato ISO 8601 UTC)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_richiesta")]
        public System.DateTimeOffset Data_richiesta { get; set; }

        /// <summary>
        /// Ragione sociale del soggetto per conto del quale √® stato vidimato il FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("denominazione_soggetto")]
        public string Denominazione_soggetto { get; set; }

        /// <summary>
        /// Codice fiscale del soggetto per conto del quale √® stato vidimato il FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("codice_fiscale_soggetto")]
        public string Codice_fiscale_soggetto { get; set; }

        /// <summary>
        /// Numero di iscrizione dell'unit√† locale del soggetto per conto del quale √® stato vidimato il FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("num_iscr_sito")]
        public string Num_iscr_sito { get; set; }

        /// <summary>
        /// Codice del blocco a cui appartiene il FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("codice_blocco")]
        public string Codice_blocco { get; set; }

        /// <summary>
        /// Nome della CCIAA di competenza del FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("cciaa_nome")]
        public string Cciaa_nome { get; set; }

        /// <summary>
        /// Stato di annullamento del FIR
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("is_annullato")]
        public bool? Is_annullato { get; set; }

        /// <summary>
        /// Data dell'eventuale annullamento del FIR (formato ISO 8601 UTC)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_annullamento")]
        public System.DateTimeOffset? Data_annullamento { get; set; }

    }

    /// <summary>
    /// Messaggio di validazione
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EsitoMessaggioModel
    {

        /// <summary>
        /// Indice dell'elemento di input relativo al messaggio di validazione
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("indice")]
        public int? Indice { get; set; }

        /// <summary>
        /// Campo dell'elemento di input relativo al messaggio di validazione
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("campo")]
        public string Campo { get; set; }

        /// <summary>
        /// Tipo del messaggio (avvertimento o errore)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("tipo")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<EsitoMessaggioTipo>))]
        public EsitoMessaggioTipo Tipo { get; set; }

        /// <summary>
        /// Codice del messaggio
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("codice_messaggio")]
        public string Codice_messaggio { get; set; }

        /// <summary>
        /// Parametri del messaggio
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("parametri")]
        public System.Collections.Generic.ICollection<object> Parametri { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum EsitoMessaggioTipo
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Errore")]
        Errore = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Avvertimento")]
        Avvertimento = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EsitoVidimazioneModel
    {

        /// <summary>
        /// Esito
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("esito")]
        public EfirPublicModel Esito { get; set; }

        /// <summary>
        /// Tipo di esito
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("tipo")]
        public string Tipo { get; set; }

        /// <summary>
        /// Identificativo della transazione asincrona
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("transazione_id")]
        public System.Guid Transazione_id { get; set; }

        /// <summary>
        /// Messaggi di validazione
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("validazione")]
        public System.Collections.Generic.ICollection<EsitoMessaggioModel> Validazione { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("errore")]
        public bool Errore { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("tempo_elaborazione")]
        public string Tempo_elaborazione { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Origine
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Portale")]
        Portale = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Api")]
        Api = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProblemDetails
    {

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("title")]
        public string Title { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public int? Status { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("detail")]
        public string Detail { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("instance")]
        public string Instance { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Risposta di stato dell'API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StatusResponse
    {

        /// <summary>
        /// Stato dell'API&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Ok&lt;/i&gt; - API regolarmente funzionante&lt;/li&gt;&lt;li&gt;&lt;i&gt;Warning&lt;/i&gt; - API funzionante, ma con probabili disservizi come indicato nei warning&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<StatusResponseEnum>))]
        public StatusResponseEnum Status { get; set; }

        /// <summary>
        /// Eventuali messaggi di warning relativi allo stato dell'API
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("warnings")]
        public System.Collections.Generic.ICollection<string> Warnings { get; set; }

    }

    /// <summary>
    /// Enumerazione dello stato dell'API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum StatusResponseEnum
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Ok")]
        Ok = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Warning")]
        Warning = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TransazioneModel
    {

        [System.Text.Json.Serialization.JsonPropertyName("transazione_id")]
        public System.Guid Transazione_id { get; set; }

    }


}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765