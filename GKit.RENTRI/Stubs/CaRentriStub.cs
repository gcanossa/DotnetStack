//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace GKit.RENTRI.Stubs.CaRentri
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CaRentriStub : BaseClient
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public CaRentriStub(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "https://api.rentri.gov.it/ca-rentri/v1.0";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Certificato CA
        /// </summary>
        /// <remarks>
        /// Ottiene il certificato di CA associato al numero di serie specificato.
        /// </remarks>
        /// <param name="num_seriale_ca_cert">Numero di serie del certificato CA.</param>
        /// <returns>Certificato CA codificato in formato DER.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> CaAsync(long num_seriale_ca_cert)
        {
            return CaAsync(num_seriale_ca_cert, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Certificato CA
        /// </summary>
        /// <remarks>
        /// Ottiene il certificato di CA associato al numero di serie specificato.
        /// </remarks>
        /// <param name="num_seriale_ca_cert">Numero di serie del certificato CA.</param>
        /// <returns>Certificato CA codificato in formato DER.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> CaAsync(long num_seriale_ca_cert, System.Threading.CancellationToken cancellationToken)
        {
            if (num_seriale_ca_cert == null)
                throw new System.ArgumentNullException("num_seriale_ca_cert");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "ca/{num_seriale_ca_cert}"
                    urlBuilder_.Append("ca/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(num_seriale_ca_cert, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// CRL
        /// </summary>
        /// <remarks>
        /// Ottiene la CRL della CA RENTRI.
        /// </remarks>
        /// <param name="num_seriale_ca_cert">Numero di serie del certificato CA.</param>
        /// <returns>CRL della CA RENTRI.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FileResponse> CrlAsync(long num_seriale_ca_cert)
        {
            return CrlAsync(num_seriale_ca_cert, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// CRL
        /// </summary>
        /// <remarks>
        /// Ottiene la CRL della CA RENTRI.
        /// </remarks>
        /// <param name="num_seriale_ca_cert">Numero di serie del certificato CA.</param>
        /// <returns>CRL della CA RENTRI.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FileResponse> CrlAsync(long num_seriale_ca_cert, System.Threading.CancellationToken cancellationToken)
        {
            if (num_seriale_ca_cert == null)
                throw new System.ArgumentNullException("num_seriale_ca_cert");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "ca/{num_seriale_ca_cert}/crl"
                    urlBuilder_.Append("ca/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(num_seriale_ca_cert, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/crl");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200 || status_ == 206)
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await ReadAsStreamAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            var fileResponse_ = new FileResponse(status_, headers_, responseStream_, null, response_);
                            disposeClient_ = false; disposeResponse_ = false; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Crea/aggiorna credenziali
        /// </summary>
        /// <remarks>
        /// Crea delle nuove credenziali associate al soggetto e al dispositivo specificati, oppure aggiorna le informazioni associate a credenziali esistenti.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="body">Dati delle credenziali.</param>
        /// <returns>Identificativo delle credenziali create/aggiornate.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CreateUpdateCredentialsResponse> CredentialsPOSTAsync(CreateUpdateCredentialsRequest body)
        {
            return CredentialsPOSTAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Crea/aggiorna credenziali
        /// </summary>
        /// <remarks>
        /// Crea delle nuove credenziali associate al soggetto e al dispositivo specificati, oppure aggiorna le informazioni associate a credenziali esistenti.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="body">Dati delle credenziali.</param>
        /// <returns>Identificativo delle credenziali create/aggiornate.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CreateUpdateCredentialsResponse> CredentialsPOSTAsync(CreateUpdateCredentialsRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials"
                    urlBuilder_.Append("credentials");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CreateUpdateCredentialsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 422)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Registrazione del dispositivo non riuscita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Dettaglio credenziali
        /// </summary>
        /// <remarks>
        /// Ottiene le informazioni di dettaglio delle credenziali specificate.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali.</param>
        /// <returns>Dettaglio delle credenziali.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CredentialsModel> CredentialsGETAsync(string credentials_id)
        {
            return CredentialsGETAsync(credentials_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Dettaglio credenziali
        /// </summary>
        /// <remarks>
        /// Ottiene le informazioni di dettaglio delle credenziali specificate.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali.</param>
        /// <returns>Dettaglio delle credenziali.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CredentialsModel> CredentialsGETAsync(string credentials_id, System.Threading.CancellationToken cancellationToken)
        {
            if (credentials_id == null)
                throw new System.ArgumentNullException("credentials_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/{credentials_id}"
                    urlBuilder_.Append("credentials/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(credentials_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CredentialsModel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Elimina credenziali
        /// </summary>
        /// <remarks>
        /// Elimina le credenziali indicate.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali da eliminare.</param>
        /// <returns>Credenziali eliminate.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task CredentialsDELETEAsync(string credentials_id)
        {
            return CredentialsDELETEAsync(credentials_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Elimina credenziali
        /// </summary>
        /// <remarks>
        /// Elimina le credenziali indicate.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali da eliminare.</param>
        /// <returns>Credenziali eliminate.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task CredentialsDELETEAsync(string credentials_id, System.Threading.CancellationToken cancellationToken)
        {
            if (credentials_id == null)
                throw new System.ArgumentNullException("credentials_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/{credentials_id}"
                    urlBuilder_.Append("credentials/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(credentials_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 422)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Eliminazione del dispositivo associato non riuscita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Cambio PIN
        /// </summary>
        /// <remarks>
        /// Imposta un nuovo PIN operativo per le credenziali specificate.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali</param>
        /// <param name="body">Dati delle credenziali e nuovo PIN.</param>
        /// <returns>PIN operativo modificato correttamente.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ChangePinAsync(string credentials_id, ChangePinRequest body)
        {
            return ChangePinAsync(credentials_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Cambio PIN
        /// </summary>
        /// <remarks>
        /// Imposta un nuovo PIN operativo per le credenziali specificate.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali</param>
        /// <param name="body">Dati delle credenziali e nuovo PIN.</param>
        /// <returns>PIN operativo modificato correttamente.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ChangePinAsync(string credentials_id, ChangePinRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (credentials_id == null)
                throw new System.ArgumentNullException("credentials_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/{credentials_id}/change-pin"
                    urlBuilder_.Append("credentials/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(credentials_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/change-pin");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida o credenziali non attive.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reset PIN
        /// </summary>
        /// <remarks>
        /// Completa la procedura di reset del PIN operativo avviata tramite la dashboard di gestione dei dispositivi, impostando un nuovo PIN per le credenziali specificate.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali</param>
        /// <param name="body">Dati delle credenziali e nuovo PIN.</param>
        /// <returns>Procedura di reset del PIN operativo completata e nuovo PIN impostato correttamente.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ResetPinAsync(string credentials_id, ResetPinRequest body)
        {
            return ResetPinAsync(credentials_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset PIN
        /// </summary>
        /// <remarks>
        /// Completa la procedura di reset del PIN operativo avviata tramite la dashboard di gestione dei dispositivi, impostando un nuovo PIN per le credenziali specificate.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali</param>
        /// <param name="body">Dati delle credenziali e nuovo PIN.</param>
        /// <returns>Procedura di reset del PIN operativo completata e nuovo PIN impostato correttamente.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ResetPinAsync(string credentials_id, ResetPinRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (credentials_id == null)
                throw new System.ArgumentNullException("credentials_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/{credentials_id}/reset-pin"
                    urlBuilder_.Append("credentials/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(credentials_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/reset-pin");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida o credenziali non attive.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Rimuovi associazione credenziali
        /// </summary>
        /// <remarks>
        /// Rimuove l'associazione delle credenziali con l'operatore o con l'unit locale specificata.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali.</param>
        /// <param name="num_iscr_sito">Identificativo dell'unit locale da rimuovere.</param>
        /// <returns>Associazione eliminata.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task RimuoviAssociazioneAsync(string credentials_id, string num_iscr_sito)
        {
            return RimuoviAssociazioneAsync(credentials_id, num_iscr_sito, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Rimuovi associazione credenziali
        /// </summary>
        /// <remarks>
        /// Rimuove l'associazione delle credenziali con l'operatore o con l'unit locale specificata.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali.</param>
        /// <param name="num_iscr_sito">Identificativo dell'unit locale da rimuovere.</param>
        /// <returns>Associazione eliminata.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RimuoviAssociazioneAsync(string credentials_id, string num_iscr_sito, System.Threading.CancellationToken cancellationToken)
        {
            if (credentials_id == null)
                throw new System.ArgumentNullException("credentials_id");

            if (num_iscr_sito == null)
                throw new System.ArgumentNullException("num_iscr_sito");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/{credentials_id}/rimuovi-associazione"
                    urlBuilder_.Append("credentials/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(credentials_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/rimuovi-associazione");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("num_iscr_sito")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(num_iscr_sito, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida o credenziali non attive.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Log firma remota
        /// </summary>
        /// <remarks>
        /// Ottiene l'elenco delle operazioni di firma remota relative alle credenziali specificate, filtrate in base ai criteri specificati.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali</param>
        /// <param name="user_name">Identificativo (Codice Fiscale) dell'utente.</param>
        /// <param name="sad_handle">Handle del SAD associato alla richiesta di autorizzazione alla firma, in caso di 2FA tramite dispositivo mobile.</param>
        /// <param name="data_da">Dalla data di firma, inclusa (formato ISO 8601 UTC)</param>
        /// <param name="data_a">Alla data di firma, esclusa (formato ISO 8601 UTC)</param>
        /// <param name="document_reference">Riferimento al documento. Per i FIR, il numero del FIR.</param>
        /// <param name="paging_Page">Valore per l'header Paging-Page.</param>
        /// <param name="paging_PageSize">Valore per l'header Paging-PageSize.</param>
        /// <returns>Elenco delle operazioni di firma remota corrispondenti ai criteri di ricerca specificati.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CredentialsSignatureLogsResponse> SignatureLogsAsync(string credentials_id, string user_name, System.Guid? sad_handle, System.DateTimeOffset? data_da, System.DateTimeOffset? data_a, string document_reference, int? paging_Page, int? paging_PageSize)
        {
            return SignatureLogsAsync(credentials_id, user_name, sad_handle, data_da, data_a, document_reference, paging_Page, paging_PageSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Log firma remota
        /// </summary>
        /// <remarks>
        /// Ottiene l'elenco delle operazioni di firma remota relative alle credenziali specificate, filtrate in base ai criteri specificati.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali</param>
        /// <param name="user_name">Identificativo (Codice Fiscale) dell'utente.</param>
        /// <param name="sad_handle">Handle del SAD associato alla richiesta di autorizzazione alla firma, in caso di 2FA tramite dispositivo mobile.</param>
        /// <param name="data_da">Dalla data di firma, inclusa (formato ISO 8601 UTC)</param>
        /// <param name="data_a">Alla data di firma, esclusa (formato ISO 8601 UTC)</param>
        /// <param name="document_reference">Riferimento al documento. Per i FIR, il numero del FIR.</param>
        /// <param name="paging_Page">Valore per l'header Paging-Page.</param>
        /// <param name="paging_PageSize">Valore per l'header Paging-PageSize.</param>
        /// <returns>Elenco delle operazioni di firma remota corrispondenti ai criteri di ricerca specificati.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CredentialsSignatureLogsResponse> SignatureLogsAsync(string credentials_id, string user_name, System.Guid? sad_handle, System.DateTimeOffset? data_da, System.DateTimeOffset? data_a, string document_reference, int? paging_Page, int? paging_PageSize, System.Threading.CancellationToken cancellationToken)
        {
            if (credentials_id == null)
                throw new System.ArgumentNullException("credentials_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (paging_Page != null)
                        request_.Headers.TryAddWithoutValidation("Paging-Page", ConvertToString(paging_Page, System.Globalization.CultureInfo.InvariantCulture));

                    if (paging_PageSize != null)
                        request_.Headers.TryAddWithoutValidation("Paging-PageSize", ConvertToString(paging_PageSize, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/{credentials_id}/signature-logs"
                    urlBuilder_.Append("credentials/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(credentials_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/signature-logs");
                    urlBuilder_.Append('?');
                    if (user_name != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("user_name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(user_name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sad_handle != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sad_handle")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sad_handle, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (data_da != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("data_da")).Append('=').Append(System.Uri.EscapeDataString(data_da.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (data_a != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("data_a")).Append('=').Append(System.Uri.EscapeDataString(data_a.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (document_reference != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("document_reference")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(document_reference, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CredentialsSignatureLogsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Bad Request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita per il Soggetto.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Stato credenziali
        /// </summary>
        /// <remarks>
        /// Ottiene le informazioni sullo stato delle credenziali.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali.</param>
        /// <returns>Stato delle credenziali.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CredentialsStatusResponse> StatusAsync(string credentials_id)
        {
            return StatusAsync(credentials_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Stato credenziali
        /// </summary>
        /// <remarks>
        /// Ottiene le informazioni sullo stato delle credenziali.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali.</param>
        /// <returns>Stato delle credenziali.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CredentialsStatusResponse> StatusAsync(string credentials_id, System.Threading.CancellationToken cancellationToken)
        {
            if (credentials_id == null)
                throw new System.ArgumentNullException("credentials_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/{credentials_id}/status"
                    urlBuilder_.Append("credentials/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(credentials_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/status");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CredentialsStatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Autorizza credenziali
        /// </summary>
        /// <remarks>
        /// Autorizza l'accesso alle credenziali per una richiesta di firma.
        /// <br/>
        /// <br/>La richiesta di autorizzazione genera l'invio di una notifica al dispositivo mobile associato alle credenziali.
        /// <br/>
        /// <br/>L'autorizzazione pu essere richiesta solamente per credenziali attive.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="body">Dati delle credenziali da autorizzare.</param>
        /// <returns>Richiesta di autorizzazione creata.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CredentialsAuthorizeResponse> AuthorizeAsync(CredentialsAuthorizeRequest body)
        {
            return AuthorizeAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Autorizza credenziali
        /// </summary>
        /// <remarks>
        /// Autorizza l'accesso alle credenziali per una richiesta di firma.
        /// <br/>
        /// <br/>La richiesta di autorizzazione genera l'invio di una notifica al dispositivo mobile associato alle credenziali.
        /// <br/>
        /// <br/>L'autorizzazione pu essere richiesta solamente per credenziali attive.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="body">Dati delle credenziali da autorizzare.</param>
        /// <returns>Richiesta di autorizzazione creata.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CredentialsAuthorizeResponse> AuthorizeAsync(CredentialsAuthorizeRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/authorize"
                    urlBuilder_.Append("credentials/authorize");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CredentialsAuthorizeResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida, credenziali non attive o certificato di firma non valido, scaduto o revocato.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 422)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Invio della notifica al dispositivo mobile non riuscita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Verifica autorizzazione credenziali
        /// </summary>
        /// <remarks>
        /// Verifica lo stato di una richiesta di autorizzazione alla firma per le credenziali.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="handle">Handle del SAD per verificare lo stato di autorizzazione della richiesta.</param>
        /// <returns>Autorizzazione concessa.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CredentialsAuthorizeResponse> AuthorizeCheckAsync(System.Guid handle)
        {
            return AuthorizeCheckAsync(handle, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Verifica autorizzazione credenziali
        /// </summary>
        /// <remarks>
        /// Verifica lo stato di una richiesta di autorizzazione alla firma per le credenziali.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="handle">Handle del SAD per verificare lo stato di autorizzazione della richiesta.</param>
        /// <returns>Autorizzazione concessa.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CredentialsAuthorizeResponse> AuthorizeCheckAsync(System.Guid handle, System.Threading.CancellationToken cancellationToken)
        {
            if (handle == null)
                throw new System.ArgumentNullException("handle");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/authorize-check/{handle}"
                    urlBuilder_.Append("credentials/authorize-check/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(handle, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CredentialsAuthorizeResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 202)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CredentialsAuthorizeResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida, credenziali non attive o autorizzazione scaduta.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita o autorizzazione non concessa.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 422)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Notifica al dispositivo mobile per la richiesta di autorizzazione non inviata.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Imposta autorizzazione credenziali
        /// </summary>
        /// <remarks>
        /// Completa il processo di autorizzazione delle credenziali per la firma.
        /// <br/>
        /// <br/>Da richiamare a seguito della ricezione della notifica sul dispositivo mobile, per impostare il consenso o meno alla richiesta di autorizzazione per la firma.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="body">Dati per l'impostazione dell'autorizzazione.</param>
        /// <returns>Stato dell'autorizzazione aggiornato.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task AuthorizeConfirmationAsync(CredentialsAuthorizeConfirmationRequest body)
        {
            return AuthorizeConfirmationAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Imposta autorizzazione credenziali
        /// </summary>
        /// <remarks>
        /// Completa il processo di autorizzazione delle credenziali per la firma.
        /// <br/>
        /// <br/>Da richiamare a seguito della ricezione della notifica sul dispositivo mobile, per impostare il consenso o meno alla richiesta di autorizzazione per la firma.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="body">Dati per l'impostazione dell'autorizzazione.</param>
        /// <returns>Stato dell'autorizzazione aggiornato.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task AuthorizeConfirmationAsync(CredentialsAuthorizeConfirmationRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/authorize-confirmation"
                    urlBuilder_.Append("credentials/authorize-confirmation");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Informazioni boarding
        /// </summary>
        /// <remarks>
        /// Verifica se il codice di boarding specificato  attivo e restituisce le informazioni necessarie al dispositivo per creare delle nuove credenziali.
        /// </remarks>
        /// <param name="qrcode_token">Token letto dal QR Code di boarding.</param>
        /// <param name="pin">PIN di boarding.</param>
        /// <returns>Accesso consentito.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BoardingAccessResponse> BoardingAsync(System.Guid qrcode_token, string pin)
        {
            return BoardingAsync(qrcode_token, pin, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Informazioni boarding
        /// </summary>
        /// <remarks>
        /// Verifica se il codice di boarding specificato  attivo e restituisce le informazioni necessarie al dispositivo per creare delle nuove credenziali.
        /// </remarks>
        /// <param name="qrcode_token">Token letto dal QR Code di boarding.</param>
        /// <param name="pin">PIN di boarding.</param>
        /// <returns>Accesso consentito.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BoardingAccessResponse> BoardingAsync(System.Guid qrcode_token, string pin, System.Threading.CancellationToken cancellationToken)
        {
            if (qrcode_token == null)
                throw new System.ArgumentNullException("qrcode_token");

            if (pin == null)
                throw new System.ArgumentNullException("pin");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/boarding/{qrcode_token}"
                    urlBuilder_.Append("credentials/boarding/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(qrcode_token, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("pin")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(pin, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BoardingAccessResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Parametri per il boarding non validi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Informazioni credenziali
        /// </summary>
        /// <remarks>
        /// Ottiene le informazioni sull'identit principale ed il certificato (o la catena di certificati) ad esso associata.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali di firma.</param>
        /// <param name="cert_info">Indica se includere nella risposta anche i parametri contenenti informazioni relative al certificato.</param>
        /// <param name="certificates">Specifica quali certificati dalla catena devono essere restituiti.</param>
        /// <param name="auth_info">Indica se includere nella risposta anche i parametri contenenti informazioni sul meccanismo di autorizzazione supportato dalle credenziali.</param>
        /// <param name="lang">Lingua prescelta per la risposta, specificata secondo RFC 5646.</param>
        /// <param name="client_data">Dati arbitrari dell'applicazione di firma.</param>
        /// <returns>Informazioni sulle credenziali.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CredentialsInfoResponse> InfoAsync(string credentials_id, bool? cert_info, CredentialsCertificate? certificates, bool? auth_info, string lang, string client_data)
        {
            return InfoAsync(credentials_id, cert_info, certificates, auth_info, lang, client_data, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Informazioni credenziali
        /// </summary>
        /// <remarks>
        /// Ottiene le informazioni sull'identit principale ed il certificato (o la catena di certificati) ad esso associata.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="credentials_id">Identificativo delle credenziali di firma.</param>
        /// <param name="cert_info">Indica se includere nella risposta anche i parametri contenenti informazioni relative al certificato.</param>
        /// <param name="certificates">Specifica quali certificati dalla catena devono essere restituiti.</param>
        /// <param name="auth_info">Indica se includere nella risposta anche i parametri contenenti informazioni sul meccanismo di autorizzazione supportato dalle credenziali.</param>
        /// <param name="lang">Lingua prescelta per la risposta, specificata secondo RFC 5646.</param>
        /// <param name="client_data">Dati arbitrari dell'applicazione di firma.</param>
        /// <returns>Informazioni sulle credenziali.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CredentialsInfoResponse> InfoAsync(string credentials_id, bool? cert_info, CredentialsCertificate? certificates, bool? auth_info, string lang, string client_data, System.Threading.CancellationToken cancellationToken)
        {
            if (credentials_id == null)
                throw new System.ArgumentNullException("credentials_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/info"
                    urlBuilder_.Append("credentials/info");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("credentials_id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(credentials_id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (cert_info != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cert_info")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cert_info, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (certificates != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("certificates")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(certificates, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (auth_info != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("auth_info")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(auth_info, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (lang != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("lang")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(lang, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (client_data != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("client_data")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(client_data, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CredentialsInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Elenco credenziali soggetto
        /// </summary>
        /// <remarks>
        /// Ottiene l'elenco delle credenziali associate ad un soggetto.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="identificativo_soggetto">Codice Fiscale di un Operatore iscritto.</param>
        /// <param name="num_iscr_sito">Numero iscrizione unit locale.</param>
        /// <param name="user_name">Identificativo (Codice Fiscale) dell'utente utilizzatore del dispositivo (da SPID, CIE, CNS).</param>
        /// <param name="credential_info">Indica se includere nella risposta anche le informazioni relative alla chiave pubblica del certificato ed il certificato stesso, oppure la catena di certificati associata alle credenziali.</param>
        /// <param name="only_valid">Indica se includere nella risposta solo credenziali utilizzabili per creare una firma valida.</param>
        /// <param name="cert_info">Indica se includere nella risposta anche i parametri contenenti informazioni relative al certificato.</param>
        /// <param name="certificates">Specifica quali certificati dalla catena devono essere restituiti.</param>
        /// <param name="auth_info">Indica se includere nella risposta anche i parametri contenenti informazioni sul meccanismo di autorizzazione supportato dalle credenziali.</param>
        /// <param name="lang">Lingua prescelta per la risposta, specificata secondo RFC 5646.</param>
        /// <param name="client_data">Dati arbitrari dell'applicazione di firma.</param>
        /// <returns>Elenco delle credenziali.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CredentialsListResponse> ListAsync(string identificativo_soggetto, string num_iscr_sito, string user_name, bool? credential_info, bool? only_valid, bool? cert_info, CredentialsCertificate? certificates, bool? auth_info, string lang, string client_data)
        {
            return ListAsync(identificativo_soggetto, num_iscr_sito, user_name, credential_info, only_valid, cert_info, certificates, auth_info, lang, client_data, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Elenco credenziali soggetto
        /// </summary>
        /// <remarks>
        /// Ottiene l'elenco delle credenziali associate ad un soggetto.
        /// <br/>
        /// <br/>Per ulteriori informazioni consultare la documentazione del CSC (Cloud Signature Consortium) relativa alle specifiche API v2.0 (20/04/2023) al link: https://cloudsignatureconsortium.org/download-api-specifications/.
        /// </remarks>
        /// <param name="identificativo_soggetto">Codice Fiscale di un Operatore iscritto.</param>
        /// <param name="num_iscr_sito">Numero iscrizione unit locale.</param>
        /// <param name="user_name">Identificativo (Codice Fiscale) dell'utente utilizzatore del dispositivo (da SPID, CIE, CNS).</param>
        /// <param name="credential_info">Indica se includere nella risposta anche le informazioni relative alla chiave pubblica del certificato ed il certificato stesso, oppure la catena di certificati associata alle credenziali.</param>
        /// <param name="only_valid">Indica se includere nella risposta solo credenziali utilizzabili per creare una firma valida.</param>
        /// <param name="cert_info">Indica se includere nella risposta anche i parametri contenenti informazioni relative al certificato.</param>
        /// <param name="certificates">Specifica quali certificati dalla catena devono essere restituiti.</param>
        /// <param name="auth_info">Indica se includere nella risposta anche i parametri contenenti informazioni sul meccanismo di autorizzazione supportato dalle credenziali.</param>
        /// <param name="lang">Lingua prescelta per la risposta, specificata secondo RFC 5646.</param>
        /// <param name="client_data">Dati arbitrari dell'applicazione di firma.</param>
        /// <returns>Elenco delle credenziali.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CredentialsListResponse> ListAsync(string identificativo_soggetto, string num_iscr_sito, string user_name, bool? credential_info, bool? only_valid, bool? cert_info, CredentialsCertificate? certificates, bool? auth_info, string lang, string client_data, System.Threading.CancellationToken cancellationToken)
        {
            if (identificativo_soggetto == null)
                throw new System.ArgumentNullException("identificativo_soggetto");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "credentials/list"
                    urlBuilder_.Append("credentials/list");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("identificativo_soggetto")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(identificativo_soggetto, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (num_iscr_sito != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("num_iscr_sito")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(num_iscr_sito, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (user_name != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("user_name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(user_name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (credential_info != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("credential_info")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(credential_info, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (only_valid != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("only_valid")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(only_valid, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cert_info != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cert_info")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cert_info, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (certificates != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("certificates")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(certificates, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (auth_info != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("auth_info")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(auth_info, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (lang != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("lang")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(lang, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (client_data != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("client_data")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(client_data, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CredentialsListResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Credenziali non trovate.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Elenco dispositivi
        /// </summary>
        /// <remarks>
        /// Ottiene l'elenco dei dispositivi, filtrati in base ai criteri specificati.
        /// </remarks>
        /// <param name="identificativo_soggetto">Codice Fiscale di un Operatore iscritto.</param>
        /// <param name="user_name">Identificativo (Codice Fiscale) dell'utente utilizzatore del dispositivo (da SPID, CIE, CNS).</param>
        /// <param name="device_id">Identificativo del dispositivo.</param>
        /// <param name="credentials_id">Identificativo delle credenziali di firma.</param>
        /// <param name="attivi">Indica se includere solamente i dispositivi attivi.</param>
        /// <param name="paging_Page">Valore per l'header Paging-Page.</param>
        /// <param name="paging_PageSize">Valore per l'header Paging-PageSize.</param>
        /// <returns>Elenco dei dispositivi corrispondenti ai criteri di ricerca specificati.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<DeviceModel>> DevicesAllAsync(string identificativo_soggetto, string user_name, string device_id, string credentials_id, bool? attivi, int? paging_Page, int? paging_PageSize)
        {
            return DevicesAllAsync(identificativo_soggetto, user_name, device_id, credentials_id, attivi, paging_Page, paging_PageSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Elenco dispositivi
        /// </summary>
        /// <remarks>
        /// Ottiene l'elenco dei dispositivi, filtrati in base ai criteri specificati.
        /// </remarks>
        /// <param name="identificativo_soggetto">Codice Fiscale di un Operatore iscritto.</param>
        /// <param name="user_name">Identificativo (Codice Fiscale) dell'utente utilizzatore del dispositivo (da SPID, CIE, CNS).</param>
        /// <param name="device_id">Identificativo del dispositivo.</param>
        /// <param name="credentials_id">Identificativo delle credenziali di firma.</param>
        /// <param name="attivi">Indica se includere solamente i dispositivi attivi.</param>
        /// <param name="paging_Page">Valore per l'header Paging-Page.</param>
        /// <param name="paging_PageSize">Valore per l'header Paging-PageSize.</param>
        /// <returns>Elenco dei dispositivi corrispondenti ai criteri di ricerca specificati.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<DeviceModel>> DevicesAllAsync(string identificativo_soggetto, string user_name, string device_id, string credentials_id, bool? attivi, int? paging_Page, int? paging_PageSize, System.Threading.CancellationToken cancellationToken)
        {
            if (identificativo_soggetto == null)
                throw new System.ArgumentNullException("identificativo_soggetto");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (paging_Page != null)
                        request_.Headers.TryAddWithoutValidation("Paging-Page", ConvertToString(paging_Page, System.Globalization.CultureInfo.InvariantCulture));

                    if (paging_PageSize != null)
                        request_.Headers.TryAddWithoutValidation("Paging-PageSize", ConvertToString(paging_PageSize, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "devices"
                    urlBuilder_.Append("devices");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("identificativo_soggetto")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(identificativo_soggetto, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (user_name != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("user_name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(user_name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (device_id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("device_id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(device_id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (credentials_id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("credentials_id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(credentials_id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (attivi != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("attivi")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(attivi, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<DeviceModel>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita per il Soggetto.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Dispositivi non trovati.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 422)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Unprocessable Content", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Dettaglio dispositivo
        /// </summary>
        /// <remarks>
        /// Ottiene informazioni di dettaglio di un dispositivo.
        /// </remarks>
        /// <param name="device_id">Criteri di ricerca dei dispositivi.</param>
        /// <param name="identificativo_soggetto">Identificativo del soggetto.</param>
        /// <returns>Informazioni su dispositivo, app e credenziali.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DeviceModel> DevicesAsync(string device_id, string identificativo_soggetto)
        {
            return DevicesAsync(device_id, identificativo_soggetto, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Dettaglio dispositivo
        /// </summary>
        /// <remarks>
        /// Ottiene informazioni di dettaglio di un dispositivo.
        /// </remarks>
        /// <param name="device_id">Criteri di ricerca dei dispositivi.</param>
        /// <param name="identificativo_soggetto">Identificativo del soggetto.</param>
        /// <returns>Informazioni su dispositivo, app e credenziali.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DeviceModel> DevicesAsync(string device_id, string identificativo_soggetto, System.Threading.CancellationToken cancellationToken)
        {
            if (device_id == null)
                throw new System.ArgumentNullException("device_id");

            if (identificativo_soggetto == null)
                throw new System.ArgumentNullException("identificativo_soggetto");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "devices/{device_id}/{identificativo_soggetto}"
                    urlBuilder_.Append("devices/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(device_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('/');
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(identificativo_soggetto, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeviceModel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita per il Soggetto.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Dispositivo non trovati.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Sincronizza dispositivo
        /// </summary>
        /// <remarks>
        /// Sincronizza le informazioni del dispositivo specificato e dell'app installata.
        /// </remarks>
        /// <param name="body">Dati del dispositivo.</param>
        /// <returns>Informazioni del dispositivo sincronizzate correttamente.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SyncAsync(SyncDeviceInfoRequest body)
        {
            return SyncAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Sincronizza dispositivo
        /// </summary>
        /// <remarks>
        /// Sincronizza le informazioni del dispositivo specificato e dell'app installata.
        /// </remarks>
        /// <param name="body">Dati del dispositivo.</param>
        /// <returns>Informazioni del dispositivo sincronizzate correttamente.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SyncAsync(SyncDeviceInfoRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "devices/sync"
                    urlBuilder_.Append("devices/sync");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            return;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita per il dispositivo.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Dispositivo non trovato.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Errore non gestito (contattare l\'assistenza).", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Info servizio
        /// </summary>
        /// <remarks>
        /// Restituisce informazioni sul servizio di firma remota e l'elenco dei metodi API implementati.
        /// </remarks>
        /// <param name="lang">Lingua prescelta per la risposta, specificata secondo RFC 5646.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<InfoData> Info2Async(string lang)
        {
            return Info2Async(lang, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Info servizio
        /// </summary>
        /// <remarks>
        /// Restituisce informazioni sul servizio di firma remota e l'elenco dei metodi API implementati.
        /// </remarks>
        /// <param name="lang">Lingua prescelta per la risposta, specificata secondo RFC 5646.</param>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InfoData> Info2Async(string lang, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "info"
                    urlBuilder_.Append("info");
                    urlBuilder_.Append('?');
                    if (lang != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("lang")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(lang, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InfoData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Log firma remota
        /// </summary>
        /// <remarks>
        /// Ottiene l'elenco delle operazioni di firma remota relative al certificato specificato.
        /// </remarks>
        /// <param name="num_seriale_ca_cert">Numero di serie del certificato CA.</param>
        /// <param name="num_seriale_cert">Numero di serie del certificato.</param>
        /// <param name="credentials_identifier">Identificativo delle credenziali di firma.</param>
        /// <param name="utente_nome_cognome">Nome e cognome dell'utente associato all'operazione di firma.</param>
        /// <param name="user_name">Identificativo (Codice Fiscale) dell'utente associato all'operazione di firma (da SPID, CIE, CNS).</param>
        /// <param name="data_da">Dalla data di firma, inclusa (formato ISO 8601 UTC)</param>
        /// <param name="data_a">Alla data di firma, esclusa (formato ISO 8601 UTC)</param>
        /// <param name="document_reference">Riferimento al documento. Per i FIR, il numero del FIR.</param>
        /// <param name="paging_Page">Valore per l'header Paging-Page.</param>
        /// <param name="paging_PageSize">Valore per l'header Paging-PageSize.</param>
        /// <returns>Elenco delle operazioni di firma remota relative al certificato specificato.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CertificateSignatureLogsResponse> CertificatoAsync(long num_seriale_ca_cert, long num_seriale_cert, string credentials_identifier, string utente_nome_cognome, string user_name, System.DateTimeOffset? data_da, System.DateTimeOffset? data_a, string document_reference, int? paging_Page, int? paging_PageSize)
        {
            return CertificatoAsync(num_seriale_ca_cert, num_seriale_cert, credentials_identifier, utente_nome_cognome, user_name, data_da, data_a, document_reference, paging_Page, paging_PageSize, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Log firma remota
        /// </summary>
        /// <remarks>
        /// Ottiene l'elenco delle operazioni di firma remota relative al certificato specificato.
        /// </remarks>
        /// <param name="num_seriale_ca_cert">Numero di serie del certificato CA.</param>
        /// <param name="num_seriale_cert">Numero di serie del certificato.</param>
        /// <param name="credentials_identifier">Identificativo delle credenziali di firma.</param>
        /// <param name="utente_nome_cognome">Nome e cognome dell'utente associato all'operazione di firma.</param>
        /// <param name="user_name">Identificativo (Codice Fiscale) dell'utente associato all'operazione di firma (da SPID, CIE, CNS).</param>
        /// <param name="data_da">Dalla data di firma, inclusa (formato ISO 8601 UTC)</param>
        /// <param name="data_a">Alla data di firma, esclusa (formato ISO 8601 UTC)</param>
        /// <param name="document_reference">Riferimento al documento. Per i FIR, il numero del FIR.</param>
        /// <param name="paging_Page">Valore per l'header Paging-Page.</param>
        /// <param name="paging_PageSize">Valore per l'header Paging-PageSize.</param>
        /// <returns>Elenco delle operazioni di firma remota relative al certificato specificato.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CertificateSignatureLogsResponse> CertificatoAsync(long num_seriale_ca_cert, long num_seriale_cert, string credentials_identifier, string utente_nome_cognome, string user_name, System.DateTimeOffset? data_da, System.DateTimeOffset? data_a, string document_reference, int? paging_Page, int? paging_PageSize, System.Threading.CancellationToken cancellationToken)
        {
            if (num_seriale_ca_cert == null)
                throw new System.ArgumentNullException("num_seriale_ca_cert");

            if (num_seriale_cert == null)
                throw new System.ArgumentNullException("num_seriale_cert");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (paging_Page != null)
                        request_.Headers.TryAddWithoutValidation("Paging-Page", ConvertToString(paging_Page, System.Globalization.CultureInfo.InvariantCulture));

                    if (paging_PageSize != null)
                        request_.Headers.TryAddWithoutValidation("Paging-PageSize", ConvertToString(paging_PageSize, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "logs/ca/{num_seriale_ca_cert}/certificato/{num_seriale_cert}"
                    urlBuilder_.Append("logs/ca/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(num_seriale_ca_cert, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/certificato/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(num_seriale_cert, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (credentials_identifier != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("credentials_identifier")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(credentials_identifier, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (utente_nome_cognome != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("utente_nome_cognome")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(utente_nome_cognome, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (user_name != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("user_name")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(user_name, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (data_da != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("data_da")).Append('=').Append(System.Uri.EscapeDataString(data_da.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (data_a != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("data_a")).Append('=').Append(System.Uri.EscapeDataString(data_a.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (document_reference != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("document_reference")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(document_reference, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CertificateSignatureLogsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Certificato non trovato.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Firma hash
        /// </summary>
        /// <remarks>
        /// Calcola la firma di uno o pi hash specificati.
        /// </remarks>
        /// <returns>Firma applicata correttamente.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SignatureResponse> SignHashAsync(SignatureRequest body)
        {
            return SignHashAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Firma hash
        /// </summary>
        /// <remarks>
        /// Calcola la firma di uno o pi hash specificati.
        /// </remarks>
        /// <returns>Firma applicata correttamente.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SignatureResponse> SignHashAsync(SignatureRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "signatures/sign-hash"
                    urlBuilder_.Append("signatures/sign-hash");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SignatureResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Richiesta non valida o credenziali non attive.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Operazione non consentita.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 422)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("SAD senza autorizzazione, mancato invio della notifica o mancata corrispondenza degli hash.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Errore non gestito (contattare l\'assistenza).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Stato API
        /// </summary>
        /// <remarks>
        /// Verifica dello stato dell'API.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<StatusResponse> Status2Async()
        {
            return Status2Async(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Stato API
        /// </summary>
        /// <remarks>
        /// Verifica dello stato dell'API.
        /// </remarks>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<StatusResponse> Status2Async(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "status"
                    urlBuilder_.Append("status");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StatusResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 423)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Sono state eseguite troppe richieste non valide. \n\t\t\t\t\t\tQuesta risposta viene restituita quando viene rilevato un numero eccessivo di richieste concorrenti, autenticate ma non valide. \n\t\t\t\t\t\tIn questo caso, le eventuali richieste valide continueranno ad essere accettate, mentre solo le richieste non valide verranno bloccate applicando un meccanismo di \"ban\" a livello di chiamante (Issuer). \n\t\t\t\t\t\tIl servizio di assistenza per l\'interoperabilit\u00e0 RENTRI potr\u00e0 essere contattato dal fruitore del servizio per i chiarimenti relativi alle richieste non valide, al fine di apportare le correzioni necessarie ai client.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 429)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("Troppe richieste. Questa risposta viene restituita quando vengono rilevate pi\u00f9 di 100 richieste in 5 secondi.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ProblemDetails>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<ProblemDetails>("Service Unavailable", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field_ = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field_ != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field_, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    /// <summary>
    /// Informazioni sulla App.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AppInfo
    {

        /// <summary>
        /// Nome dell'applicazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(50, MinimumLength = 1)]
        public string Name { get; set; }

        /// <summary>
        /// Nome del package o identificativo dell'applicazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("package_name")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength = 1)]
        public string Package_name { get; set; }

        /// <summary>
        /// Versione dell'applicazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("version")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(14, MinimumLength = 1)]
        public string Version { get; set; }

        /// <summary>
        /// Numero della build della versione dell'applicazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("build")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(14, MinimumLength = 1)]
        public string Build { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthData
    {

        /// <summary>
        /// Modalit di autorizzazione.&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Implicit&lt;/i&gt; - Il processo autorizzativo  gestito dal servizio. I fattori autenticativi sono gestiti dal servizio interagendo direttamente con l'utente, e non con l'applicazione di firma.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Explicit&lt;/i&gt; - Il processo autorizzativo  gestito dall'applicazione di firma, che gestisce i fattori di autenticazione come PIN o One-Time Password (OTP).&lt;/li&gt;&lt;li&gt;&lt;i&gt;Oauth2Code&lt;/i&gt; - Il processo autorizzativo  gestito da un servizio di autenticazione utilizzando OAuth 2.0.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Oauth2Token&lt;/i&gt; - Il processo autorizzativo  gestito da un servizio di autenticazione utilizzando OAuth 2.0.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("mode")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<AuthMode>))]
        public AuthMode? Mode { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("expression")]
        public string Expression { get; set; }

        /// <summary>
        /// Informazioni sui metodi di autenticazione disponibili.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("objects")]
        public System.Collections.Generic.ICollection<AuthObjectInfo> Objects { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AuthMode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Implicit")]
        Implicit = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Explicit")]
        Explicit = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Oauth2Code")]
        Oauth2Code = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Oauth2Token")]
        Oauth2Token = 3,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthObjectData
    {

        /// <summary>
        /// Identificativo del metodo di autenticazione. Attualmente  supportato solo il valore "mobile".
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"(?i)^mobile$")]
        public string Id { get; set; }

        /// <summary>
        /// Utilizzato per indicare il valore del fattore di autenticazione. Inutilizzato per il metodo "mobile".
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("value")]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthObjectInfo
    {

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("format")]
        public string Format { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("generator")]
        public string Generator { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("label")]
        public string Label { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BoardingAccessResponse
    {

        /// <summary>
        /// Identificativo del soggetto.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo_soggetto")]
        public string Identificativo_soggetto { get; set; }

        /// <summary>
        /// Denominazione del soggetto.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("denominazione_soggetto")]
        public string Denominazione_soggetto { get; set; }

        /// <summary>
        /// Numero di iscrizione dell'operatore.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("num_iscr_operatore")]
        public string Num_iscr_operatore { get; set; }

        /// <summary>
        /// Numero di iscrizione del sito.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("num_iscr_sito")]
        public string Num_iscr_sito { get; set; }

        /// <summary>
        /// Nome del sito.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("nome_sito")]
        public string Nome_sito { get; set; }

        /// <summary>
        /// Token di identificazione a autorizzazione della richiesta di boarding.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("token")]
        public System.Guid? Token { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CertData
    {

        /// <summary>
        /// Stato del certificato.&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Valid&lt;/i&gt; - Valido.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Expired&lt;/i&gt; - Scaduto.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Revoked&lt;/i&gt; - Revocato.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Suspended&lt;/i&gt; - Sospeso.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<CertStatus>))]
        public CertStatus Status { get; set; }

        /// <summary>
        /// Codifica base 64 dei certificati X.509.
        /// <br/>Se il parametro certificates  "chain",  presente l'intera catena di certificati con il certificato dell'ente finale nella prima posizione dell'elenco.
        /// <br/>Se il parametro certificates  single,  presente solo il certificato dell'entit finale.
        /// <br/>Se il parametro certificates  "none", non  presente alcun certificato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("certificates")]
        public System.Collections.Generic.ICollection<string> Certificates { get; set; }

        /// <summary>
        /// Emittente del certificato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("issuer_dn")]
        public string Issuer_dn { get; set; }

        /// <summary>
        /// Serial number del certificato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("serial_number")]
        public string Serial_number { get; set; }

        /// <summary>
        /// Soggetto del certificato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("subject_dn")]
        public string Subject_dn { get; set; }

        /// <summary>
        /// Data di inizio validit del certificato (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("valid_from")]
        public System.DateTimeOffset Valid_from { get; set; }

        /// <summary>
        /// Data di fine validit del certificato (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("valid_to")]
        public System.DateTimeOffset Valid_to { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CertStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Valid")]
        Valid = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Expired")]
        Expired = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Revoked")]
        Revoked = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Suspended")]
        Suspended = 3,

    }

    /// <summary>
    /// Informazioni sul certificato.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CertificateInfoModel
    {

        /// <summary>
        /// Numero seriale.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("serial_number")]
        public long? Serial_number { get; set; }

        /// <summary>
        /// Distinguished Name (DN) del soggetto intestatario del certificato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("subject_dn")]
        public string Subject_dn { get; set; }

        /// <summary>
        /// Data di rilascio (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_rilascio")]
        public System.DateTimeOffset? Data_rilascio { get; set; }

        /// <summary>
        /// Data di scadenza (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_scadenza")]
        public System.DateTimeOffset? Data_scadenza { get; set; }

        /// <summary>
        /// Data di revoca (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_revoca")]
        public System.DateTimeOffset? Data_revoca { get; set; }

    }

    /// <summary>
    /// Informazioni sull'operazione di firma remota.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CertificateOperationInfoModel
    {

        /// <summary>
        /// Informazioni di base delle credenziali di firma associate al dispositivo mobile.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("credentials_info")]
        public CredentialsInfoModel Credentials_info { get; set; }

        /// <summary>
        /// Handle del SAD associato alla richiesta di autorizzazione alla firma, in caso di 2FA tramite dispositivo mobile.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sad_handle")]
        public System.Guid? Sad_handle { get; set; }

        /// <summary>
        /// Nome e cognome dell'utente utilizzatore del dispositivo associato alle credenziali di firma, al momento dell'operazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_nome_cognome")]
        public string Utente_nome_cognome { get; set; }

        /// <summary>
        /// Identificativo alternativo o aggiuntivo dell'utente utilizzatore del dispositivo associato alle credenziali di firma, al momento dell'operazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_identificativo_altro")]
        public string Utente_identificativo_altro { get; set; }

        /// <summary>
        /// Identificativo (Codice Fiscale) dell'utente utilizzatore del dispositivo associato alle credenziali di firma (da SPID, CIE, CNS), al momento dell'operazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("user_name")]
        public string User_name { get; set; }

        /// <summary>
        /// Descrizione dell'operazione associata alla richiesta di autorizzazione alla firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Data del consenso alla firma (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_consenso")]
        public System.DateTimeOffset? Data_consenso { get; set; }

        /// <summary>
        /// Data dichiarata di firma (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_firma")]
        public System.DateTimeOffset? Data_firma { get; set; }

        /// <summary>
        /// Indica se l'utente ha approvato o meno la richiesta di autorizzazione alla firma, in caso di 2FA tramite dispositivo mobile.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("consenso")]
        public bool? Consenso { get; set; }

        /// <summary>
        /// Elenco dei codici hash associati alla richiesta di firma, codificati in base 64.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("hashes")]
        public System.Collections.Generic.ICollection<HashData> Hashes { get; set; }

    }

    /// <summary>
    /// Informazioni di dettaglio sulle operazioni di firma remota relative al certificato.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CertificateSignatureLogsResponse
    {

        /// <summary>
        /// Informazioni sul certificato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("certificate_info")]
        public CertificateInfoModel Certificate_info { get; set; }

        /// <summary>
        /// Lista delle operazioni di firma remota effettuate.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("operations")]
        public System.Collections.Generic.ICollection<CertificateOperationInfoModel> Operations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ChangePinRequest
    {

        /// <summary>
        /// PIN corrente.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("current_pin")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(6, MinimumLength = 6)]
        public string Current_pin { get; set; }

        /// <summary>
        /// Nuovo PIN.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("new_pin")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(6, MinimumLength = 6)]
        public string New_pin { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateUpdateCredentialsRequest
    {

        /// <summary>
        /// Codice Fiscale di un Operatore iscritto.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo_soggetto")]
        [System.ComponentModel.DataAnnotations.Required]
        public string Identificativo_soggetto { get; set; }

        /// <summary>
        /// Numero iscrizione unit locale.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("num_iscr_sito")]
        [System.ComponentModel.DataAnnotations.StringLength(22, MinimumLength = 22)]
        public string Num_iscr_sito { get; set; }

        /// <summary>
        /// Identificativo del soggetto associato alle credenziali di firma.
        /// <br/>
        /// <br/> Deprecato: utilizzare "utente_nome_cognome"
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo")]
        [System.ComponentModel.DataAnnotations.StringLength(100)]
        [System.Obsolete]
        public string Identificativo { get; set; }

        /// <summary>
        /// Nome e cognome dell'utente utilizzatore del dispositivo associato alle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_nome_cognome")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(100, MinimumLength = 1)]
        public string Utente_nome_cognome { get; set; }

        /// <summary>
        /// Identificativo alternativo del soggetto associato alle credenziali di firma.
        /// <br/>
        /// <br/> Deprecato: utilizzare "utente_identificativo_altro"
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo_altro")]
        [System.ComponentModel.DataAnnotations.StringLength(100)]
        [System.Obsolete]
        public string Identificativo_altro { get; set; }

        /// <summary>
        /// Identificativo alternativo o aggiuntivo dell'utente utilizzatore del dispositivo associato alle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_identificativo_altro")]
        [System.ComponentModel.DataAnnotations.StringLength(100)]
        public string Utente_identificativo_altro { get; set; }

        /// <summary>
        /// Identificativo (Codice Fiscale) dell'utente utilizzatore del dispositivo associato alle credenziali di firma (da SPID, CIE, CNS).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("user_name")]
        [System.ComponentModel.DataAnnotations.StringLength(256)]
        public string User_name { get; set; }

        /// <summary>
        /// Informazioni sul dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("device_info")]
        [System.ComponentModel.DataAnnotations.Required]
        public DeviceInfo Device_info { get; set; } = new DeviceInfo();

        /// <summary>
        /// Informazioni sulla App.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("app_info")]
        [System.ComponentModel.DataAnnotations.Required]
        public AppInfo App_info { get; set; } = new AppInfo();

        /// <summary>
        /// Token di identificazione e autorizzazione della richiesta di boarding.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("boarding_token")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Boarding_token { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateUpdateCredentialsResponse
    {

        /// <summary>
        /// Identificativo delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("credentials_id")]
        public string Credentials_id { get; set; }

        /// <summary>
        /// PIN.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("pin")]
        public string Pin { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsAuthorizeConfirmationRequest
    {

        /// <summary>
        /// Identificativo delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("credentials_id")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(9, MinimumLength = 9)]
        public string Credentials_id { get; set; }

        /// <summary>
        /// Handle del SAD da autorizzare.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("handle")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Handle { get; set; }

        /// <summary>
        /// OTP ricevuto con la notifica.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("otp")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(6, MinimumLength = 6)]
        public string Otp { get; set; }

        /// <summary>
        /// Consenso.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("allowed")]
        public bool Allowed { get; set; }

        /// <summary>
        /// PIN delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("pin")]
        [System.ComponentModel.DataAnnotations.Required]
        public string Pin { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsAuthorizeRequest
    {

        /// <summary>
        /// Identificativo delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("credentials_id")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(9, MinimumLength = 9)]
        public string Credentials_id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("num_signatures")]
        public int Num_signatures { get; set; }

        /// <summary>
        /// Elenco dei codici hash da firmare in formato base 64. Attualmente  consentito l'invio di un solo codice hash.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("hashes")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Hashes { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// OID dell'algoritmo utilizzato per calcolare l'hash fisso a 2.16.840.1.101.3.4.2.1 (SHA256)
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("hash_algo")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^2\.16\.840\.1\.101\.3\.4\.2\.1$")]
        public string Hash_algo { get; set; }

        /// <summary>
        /// Descrizione dell'operazione associata alla richiesta di autorizzazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(1000, MinimumLength = 1)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Za-z---0-9\s\.,;:!?\-\(\)/%&@]*$")]
        public string Description { get; set; }

        /// <summary>
        /// Metodo di autenticazione abbinato alle credenziali.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("auth_data")]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<AuthObjectData> Auth_data { get; set; }

        /// <summary>
        /// Dati arbitrari dell'applicazione di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("client_data")]
        public string Client_data { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsAuthorizeResponse
    {

        /// <summary>
        /// SAD (Signature Activation Data), solo nel caso in cui la richiesta di autorizzazione abbia avuto successo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sad")]
        public string Sad { get; set; }

        /// <summary>
        /// La durata del SAD espressa in secondi (default 60), solo nel caso in cui l'autorizzazione sia stata concessa.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("expires_in")]
        public int? Expires_in { get; set; }

        /// <summary>
        /// Handle del SAD per verificare lo stato di autorizzazione della richiesta.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("handle")]
        public string Handle { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CredentialsCertificate
    {

        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Single")]
        Single = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Chain")]
        Chain = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsInfo
    {

        /// <summary>
        /// Identificativo delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("credentials_id")]
        public string Credentials_id { get; set; }

        /// <summary>
        /// Descrizione delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Identificativo che qualifica il tipo di firma per cui sono adatte le credenziali.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("signature_qualifier")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<SignatureQualifier>))]
        public SignatureQualifier? Signature_qualifier { get; set; }

        /// <summary>
        /// Informazioni sulla chiave di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("key")]
        public KeyData Key { get; set; }

        /// <summary>
        /// Informazioni sul certificato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("cert")]
        public CertData Cert { get; set; }

        /// <summary>
        /// Informazioni sulla modalit di autorizzazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("auth")]
        public AuthData Auth { get; set; }

        /// <summary>
        /// Indica se il servizio di autorizzazione genera un Signature Activation Data (SAD) che contiene un collegamento con i codici hash da firmare.
        /// <br/>1 - non collegato (default)
        /// <br/>2 - collegato
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("scal")]
        public string Scal { get; set; }

        /// <summary>
        /// Numero massimo di firme che possono essere create con queste credenziali con una singola richiesta.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("multisign")]
        public int? Multisign { get; set; }

        /// <summary>
        /// Lingua prescelta per la risposta, specificata secondo RFC 5646.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("lang")]
        public string Lang { get; set; }

    }

    /// <summary>
    /// Informazioni di base delle credenziali di firma.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsInfoModel
    {

        /// <summary>
        /// Identificativo delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Identificativo del soggetto associato alle credenziali di firma.
        /// <br/>
        /// <br/> Deprecato: utilizzare "utente_nome_cognome"
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo")]
        [System.Obsolete]
        public string Identificativo { get; set; }

        /// <summary>
        /// Nome e cognome dell'utente utilizzatore del dispositivo associato alle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_nome_cognome")]
        public string Utente_nome_cognome { get; set; }

        /// <summary>
        /// Identificativo alternativo del soggetto associato alle credenziali di firma.
        /// <br/>
        /// <br/> Deprecato: utilizzare "utente_identificativo_altro"
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo_altro")]
        [System.Obsolete]
        public string Identificativo_altro { get; set; }

        /// <summary>
        /// Identificativo alternativo o aggiuntivo dell'utente utilizzatore del dispositivo associato alle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_identificativo_altro")]
        public string Utente_identificativo_altro { get; set; }

        /// <summary>
        /// Identificativo (Codice Fiscale) dell'utente utilizzatore del dispositivo associato alle credenziali di firma (da SPID, CIE, CNS).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("user_name")]
        public string User_name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsInfoResponse
    {

        /// <summary>
        /// Descrizione delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Identificativo che qualifica il tipo di firma per cui sono adatte le credenziali.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("signature_qualifier")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<SignatureQualifier>))]
        public SignatureQualifier? Signature_qualifier { get; set; }

        /// <summary>
        /// Informazioni sulla chiave di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("key")]
        public KeyData Key { get; set; }

        /// <summary>
        /// Informazioni sul certificato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("cert")]
        public CertData Cert { get; set; }

        /// <summary>
        /// Informazioni sulla modalit di autorizzazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("auth")]
        public AuthData Auth { get; set; }

        /// <summary>
        /// Indica se il servizio di autorizzazione genera un Signature Activation Data (SAD) che contiene un collegamento con i codici hash da firmare.
        /// <br/>1 - non collegato (default)
        /// <br/>2 - collegato
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("scal")]
        public string Scal { get; set; }

        /// <summary>
        /// Numero massimo di firme che possono essere create con queste credenziali con una singola richiesta.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("multisign")]
        public int? Multisign { get; set; }

        /// <summary>
        /// Lingua prescelta per la risposta, specificata secondo RFC 5646.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("lang")]
        public string Lang { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsListResponse
    {

        /// <summary>
        /// Uno o pi identificativi delle credenziali di firma associate al dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("credentials_ids")]
        public System.Collections.Generic.ICollection<string> Credentials_ids { get; set; }

        /// <summary>
        /// Specifiche relative a ciascun identificativo delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("credentials_infos")]
        public System.Collections.Generic.ICollection<CredentialsInfo> Credentials_infos { get; set; }

        /// <summary>
        /// Indica se sono state incluse nella risposta solo credenziali di firma utilizzabili per creare una firma valida.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("only_valid")]
        public bool? Only_valid { get; set; }

    }

    /// <summary>
    /// Informazioni dettagliate delle credenziali di firma.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsModel
    {

        /// <summary>
        /// Data dell'ultimo accesso effettuato (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("ultimo_accesso")]
        public System.DateTimeOffset? Ultimo_accesso { get; set; }

        /// <summary>
        /// Data di eliminazione (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_eliminazione")]
        public System.DateTimeOffset? Data_eliminazione { get; set; }

        /// <summary>
        /// Data di scadenza della richiesta di reset del PIN (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_scadenza_richiesta_pin_reset")]
        public System.DateTimeOffset? Data_scadenza_richiesta_pin_reset { get; set; }

        /// <summary>
        /// Stato.&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Attivo&lt;/i&gt; - Utilizzato per: Certificati, Dispositivi e Credenziali.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Eliminato&lt;/i&gt; - Utilizzato per Certificati e Dispositivi.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Nuovo&lt;/i&gt; - Utilizzato per Certificati.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Revocato&lt;/i&gt; - Utilizzato per Certificati e Credenziali (eliminate).&lt;/li&gt;&lt;li&gt;&lt;i&gt;Scaduto&lt;/i&gt; - Utilizzato per Certificati.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Inattivo&lt;/i&gt; - Utilizzato per Credenziali (stato assegnato a seguito del blocco del corrispondente dispositivo).&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("stato")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<Stato>))]
        public Stato? Stato { get; set; }

        /// <summary>
        /// Elenco delle unit locali sulle quali  possibile operare.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("siti")]
        public System.Collections.Generic.ICollection<string> Siti { get; set; }

        /// <summary>
        /// Identificativo del dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("device_identifier")]
        public string Device_identifier { get; set; }

        /// <summary>
        /// Indica se il device  stato bloccato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("device_is_banned")]
        public bool? Device_is_banned { get; set; }

        /// <summary>
        /// Identificativo delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Identificativo del soggetto associato alle credenziali di firma.
        /// <br/>
        /// <br/> Deprecato: utilizzare "utente_nome_cognome"
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo")]
        [System.Obsolete]
        public string Identificativo { get; set; }

        /// <summary>
        /// Nome e cognome dell'utente utilizzatore del dispositivo associato alle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_nome_cognome")]
        public string Utente_nome_cognome { get; set; }

        /// <summary>
        /// Identificativo alternativo del soggetto associato alle credenziali di firma.
        /// <br/>
        /// <br/> Deprecato: utilizzare "utente_identificativo_altro"
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo_altro")]
        [System.Obsolete]
        public string Identificativo_altro { get; set; }

        /// <summary>
        /// Identificativo alternativo o aggiuntivo dell'utente utilizzatore del dispositivo associato alle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_identificativo_altro")]
        public string Utente_identificativo_altro { get; set; }

        /// <summary>
        /// Identificativo (Codice Fiscale) dell'utente utilizzatore del dispositivo associato alle credenziali di firma (da SPID, CIE, CNS).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("user_name")]
        public string User_name { get; set; }

    }

    /// <summary>
    /// Informazioni sull'operazione di firma remota eseguita tramite dispositivo mobile.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsOperationInfoModel
    {

        /// <summary>
        /// Informazioni sul certificato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("certificate_info")]
        public CertificateInfoModel Certificate_info { get; set; }

        /// <summary>
        /// Handle del SAD associato alla richiesta di autorizzazione alla firma, in caso di 2FA tramite dispositivo mobile.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sad_handle")]
        public System.Guid? Sad_handle { get; set; }

        /// <summary>
        /// Nome e cognome dell'utente utilizzatore del dispositivo associato alle credenziali di firma, al momento dell'operazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_nome_cognome")]
        public string Utente_nome_cognome { get; set; }

        /// <summary>
        /// Identificativo alternativo o aggiuntivo dell'utente utilizzatore del dispositivo associato alle credenziali di firma, al momento dell'operazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_identificativo_altro")]
        public string Utente_identificativo_altro { get; set; }

        /// <summary>
        /// Identificativo (Codice Fiscale) dell'utente utilizzatore del dispositivo associato alle credenziali di firma (da SPID, CIE, CNS), al momento dell'operazione.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("user_name")]
        public string User_name { get; set; }

        /// <summary>
        /// Descrizione dell'operazione associata alla richiesta di autorizzazione alla firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Data del consenso alla firma (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_consenso")]
        public System.DateTimeOffset? Data_consenso { get; set; }

        /// <summary>
        /// Data dichiarata di firma (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_firma")]
        public System.DateTimeOffset? Data_firma { get; set; }

        /// <summary>
        /// Indica se l'utente ha approvato o meno la richiesta di autorizzazione alla firma, in caso di 2FA tramite dispositivo mobile.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("consenso")]
        public bool? Consenso { get; set; }

        /// <summary>
        /// Elenco dei codici hash associati alla richiesta di firma, codificati in base 64.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("hashes")]
        public System.Collections.Generic.ICollection<HashData> Hashes { get; set; }

    }

    /// <summary>
    /// Informazioni di dettaglio sulle operazioni di firma remota relative alle credenziali.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsSignatureLogsResponse
    {

        /// <summary>
        /// Informazioni di base delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("credentials_info")]
        public CredentialsInfoModel Credentials_info { get; set; }

        /// <summary>
        /// Lista delle operazioni di firma remota effettuate.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("operations")]
        public System.Collections.Generic.ICollection<CredentialsOperationInfoModel> Operations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsSito
    {

        [System.Text.Json.Serialization.JsonPropertyName("num_iscr_sito")]
        public string Num_iscr_sito { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("nome")]
        public string Nome { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("indirizzo")]
        public string Indirizzo { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("civico")]
        public string Civico { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("comune_id")]
        public string Comune_id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("provincia_id")]
        public string Provincia_id { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CredentialsStatusResponse
    {

        /// <summary>
        /// Identificativo delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Identificativo del soggetto associato alle credenziali di firma.
        /// <br/>
        /// <br/> Deprecato: utilizzare "utente_nome_cognome"
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo")]
        [System.Obsolete]
        public string Identificativo { get; set; }

        /// <summary>
        /// Nome e cognome dell'utente utilizzatore del dispositivo associato alle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_nome_cognome")]
        public string Utente_nome_cognome { get; set; }

        /// <summary>
        /// Identificativo alternativo del soggetto associato alle credenziali di firma.
        /// <br/>
        /// <br/> Deprecato: utilizzare "utente_identificativo_altro"
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo_altro")]
        [System.Obsolete]
        public string Identificativo_altro { get; set; }

        /// <summary>
        /// Identificativo alternativo o aggiuntivo dell'utente utilizzatore del dispositivo associato alle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("utente_identificativo_altro")]
        public string Utente_identificativo_altro { get; set; }

        /// <summary>
        /// Identificativo (Codice Fiscale) dell'utente utilizzatore del dispositivo associato alle credenziali di firma (da SPID, CIE, CNS).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("user_name")]
        public string User_name { get; set; }

        /// <summary>
        /// Stato.&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Attivo&lt;/i&gt; - Utilizzato per: Certificati, Dispositivi e Credenziali.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Eliminato&lt;/i&gt; - Utilizzato per Certificati e Dispositivi.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Nuovo&lt;/i&gt; - Utilizzato per Certificati.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Revocato&lt;/i&gt; - Utilizzato per Certificati e Credenziali (eliminate).&lt;/li&gt;&lt;li&gt;&lt;i&gt;Scaduto&lt;/i&gt; - Utilizzato per Certificati.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Inattivo&lt;/i&gt; - Utilizzato per Credenziali (stato assegnato a seguito del blocco del corrispondente dispositivo).&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("stato")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<Stato>))]
        public Stato Stato { get; set; }

        /// <summary>
        /// Elenco delle unit locali sulle quali  possibile operare.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("siti")]
        public System.Collections.Generic.ICollection<CredentialsSito> Siti { get; set; }

        /// <summary>
        /// Indica se le credenziali sono abbinate direttamente al soggetto.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("is_abbinato_solo_soggetto")]
        public bool Is_abbinato_solo_soggetto { get; set; }

    }

    /// <summary>
    /// Informazioni sul dispositivo.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeviceInfo
    {

        /// <summary>
        /// Identificativo del dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identifier")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(50, MinimumLength = 1)]
        public string Identifier { get; set; }

        /// <summary>
        /// Modello del dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("model")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(50, MinimumLength = 1)]
        public string Model { get; set; }

        /// <summary>
        /// Produttore del dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("manufacturer")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(50, MinimumLength = 1)]
        public string Manufacturer { get; set; }

        /// <summary>
        /// Nome del dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(150, MinimumLength = 1)]
        public string Name { get; set; }

        /// <summary>
        /// Versione del Sistema Operativo del dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("os_version")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(14, MinimumLength = 1)]
        public string Os_version { get; set; }

        /// <summary>
        /// Stile del dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("form_factor")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(20, MinimumLength = 1)]
        public string Form_factor { get; set; }

        /// <summary>
        /// Tipo di dispositivo.&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Physical&lt;/i&gt; - Dispositivo fisico&lt;/li&gt;&lt;li&gt;&lt;i&gt;Virtual&lt;/i&gt; - Dispositivo virtuale&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<DeviceType>))]
        public DeviceType Type { get; set; }

        /// <summary>
        /// Piattaforma del dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("platform")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(20, MinimumLength = 1)]
        public string Platform { get; set; }

        /// <summary>
        /// URI di callback alla quale verranno inviati in POST i dati delle notifiche RENTRI.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("notification_callback_uri")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(2000, MinimumLength = 1)]
        public string Notification_callback_uri { get; set; }

        /// <summary>
        /// Dizionario di parametri custom che verranno inviati, tra i dati delle notifiche, all'URI di callback.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("notification_callback_parameters")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, string> Notification_callback_parameters { get; set; } = new System.Collections.Generic.Dictionary<string, string>();

    }

    /// <summary>
    /// Dati di base del dispositivo e informazioni sulla registrazione al servizio di smistamento delle notifiche RENTRI.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeviceModel
    {

        /// <summary>
        /// Identificativo del dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identifier")]
        public string Identifier { get; set; }

        /// <summary>
        /// Nome.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// Modello.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("model")]
        public string Model { get; set; }

        /// <summary>
        /// Produttore.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("manufacturer")]
        public string Manufacturer { get; set; }

        /// <summary>
        /// Versione del Sistema Operativo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("os_version")]
        public string Os_version { get; set; }

        /// <summary>
        /// Formato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("form_factor")]
        public string Form_factor { get; set; }

        /// <summary>
        /// Tipo di dispositivo (fisico, virtuale).&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Physical&lt;/i&gt; - Dispositivo fisico&lt;/li&gt;&lt;li&gt;&lt;i&gt;Virtual&lt;/i&gt; - Dispositivo virtuale&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<DeviceType>))]
        public DeviceType? Type { get; set; }

        /// <summary>
        /// Piattaforma o Sistema Operativo (Android, iOS, Windows).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("platform")]
        public string Platform { get; set; }

        /// <summary>
        /// Data di registrazione (formato ISO 8601 UTC).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("data_registrazione")]
        public System.DateTimeOffset? Data_registrazione { get; set; }

        /// <summary>
        /// Indica se il dispositivo  stato bloccato.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("is_banned")]
        public bool? Is_banned { get; set; }

        /// <summary>
        /// Stato.&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Attivo&lt;/i&gt; - Utilizzato per: Certificati, Dispositivi e Credenziali.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Eliminato&lt;/i&gt; - Utilizzato per Certificati e Dispositivi.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Nuovo&lt;/i&gt; - Utilizzato per Certificati.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Revocato&lt;/i&gt; - Utilizzato per Certificati e Credenziali (eliminate).&lt;/li&gt;&lt;li&gt;&lt;i&gt;Scaduto&lt;/i&gt; - Utilizzato per Certificati.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Inattivo&lt;/i&gt; - Utilizzato per Credenziali (stato assegnato a seguito del blocco del corrispondente dispositivo).&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("stato")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<Stato>))]
        public Stato? Stato { get; set; }

        /// <summary>
        /// Nome dell'app installata.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("app_name")]
        public string App_name { get; set; }

        /// <summary>
        /// Nome del package dell'app installata.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("app_package_name")]
        public string App_package_name { get; set; }

        /// <summary>
        /// Versione dell'app installata.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("app_version")]
        public string App_version { get; set; }

        /// <summary>
        /// Numero di build dell'app installata.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("app_build")]
        public string App_build { get; set; }

        /// <summary>
        /// URI di callback alla quale verranno inviati in POST i dati delle notifiche RENTRI.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("notification_callback_uri")]
        public string Notification_callback_uri { get; set; }

        /// <summary>
        /// Dizionario di parametri custom che verranno inviati, tra i dati delle notifiche, all'URI di callback.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("notification_callback_parameters")]
        public System.Collections.Generic.IDictionary<string, string> Notification_callback_parameters { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum DeviceType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Physical")]
        Physical = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Virtual")]
        Virtual = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum DocumentType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Generic")]
        Generic = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"FIR")]
        FIR = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HashData
    {

        /// <summary>
        /// Hash del documento, in formato base 64.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("hash")]
        public string Hash { get; set; }

        /// <summary>
        /// Riferimento al documento. Per i FIR, il numero del FIR.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("reference")]
        public string Reference { get; set; }

        /// <summary>
        /// Tipo di documento.&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Generic&lt;/i&gt; - Documento generico.&lt;/li&gt;&lt;li&gt;&lt;i&gt;FIR&lt;/i&gt; - Formulario digitale.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("document_type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<DocumentType>))]
        public DocumentType? Document_type { get; set; }

        /// <summary>
        /// Informazioni aggiuntive relative al documento. Per i FIR, la fase del FIR.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("info")]
        public string Info { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InfoData
    {

        /// <summary>
        /// Versione della specifica CSC implementata.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("specs")]
        public string Specs { get; set; }

        /// <summary>
        /// Nome commerciale del servizio.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// L'URI del file immagine del logo del servizio.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("logo")]
        public string Logo { get; set; }

        /// <summary>
        /// Codice ISO 3166-1 del paese in cui il fornitore di servizi  stabilito.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("region")]
        public string Region { get; set; }

        /// <summary>
        /// Lingua utilizzata per la risposta, specificata secondo RFC 5646.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("lang")]
        public string Lang { get; set; }

        /// <summary>
        /// Descrizione del servizio.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Metodi di autenticazione supportati dal servizio.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("auth_type")]
        public System.Collections.Generic.ICollection<string> Auth_type { get; set; }

        /// <summary>
        /// URI di base del server di autorizzazione OAuth 2.0.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("oauth2")]
        public string Oauth2 { get; set; }

        /// <summary>
        /// Elenco dei nomi di tutti i metodi API implementati dal servizio.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("methods")]
        public System.Collections.Generic.ICollection<string> Methods { get; set; }

        /// <summary>
        /// Algoritmi di firma supportati dal servizio.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sign_algorithms")]
        public SignAlgorithms Sign_algorithms { get; set; }

        /// <summary>
        /// Formati di firma supportati dal servizio.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("signature_formats")]
        public SignatureFormats Signature_formats { get; set; }

        /// <summary>
        /// Elenco dei livelli di conformit della firma supportati dal servizio.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("conformance_levels")]
        public System.Collections.Generic.ICollection<string> Conformance_levels { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyData
    {

        /// <summary>
        /// Stato della chiave di firma.&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Enabled&lt;/i&gt; - Chiave abilitata ed utilizzabile per la firma.&lt;/li&gt;&lt;li&gt;&lt;i&gt;Disabled&lt;/i&gt; - Chiave disabilitata e non utilizzabile per la firma.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<KeyStatus>))]
        public KeyStatus Status { get; set; }

        /// <summary>
        /// Elenco degli OID degli algoritmi chiave supportati.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("algo")]
        public System.Collections.Generic.ICollection<string> Algo { get; set; }

        /// <summary>
        /// Lunghezza della chiave crittografica in bit.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("len")]
        public int? Len { get; set; }

        /// <summary>
        /// OID della curva ECDSA.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("curve")]
        public string Curve { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum KeyStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Enabled")]
        Enabled = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Disabled")]
        Disabled = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProblemDetails
    {

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("title")]
        public string Title { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("status")]
        public int? Status { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("detail")]
        public string Detail { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("instance")]
        public string Instance { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PushNotification
    {

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<PushNotificationType>))]
        public PushNotificationType Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("credentials_id")]
        public string Credentials_id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("device")]
        [System.ComponentModel.DataAnnotations.Required]
        public PushNotificationDevice Device { get; set; } = new PushNotificationDevice();

        [System.Text.Json.Serialization.JsonPropertyName("rentri_push_notification")]
        [System.ComponentModel.DataAnnotations.Required]
        public RentriPushNotification Rentri_push_notification { get; set; } = new RentriPushNotification();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PushNotificationDevice
    {

        [System.Text.Json.Serialization.JsonPropertyName("identifier")]
        [System.ComponentModel.DataAnnotations.Required]
        public string Identifier { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("notification_callback_uri")]
        [System.ComponentModel.DataAnnotations.Required]
        public string Notification_callback_uri { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("notification_callback_parameters")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, string> Notification_callback_parameters { get; set; } = new System.Collections.Generic.Dictionary<string, string>();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PushNotificationDeviceInfo
    {

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<PushNotificationType>))]
        public PushNotificationType Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("is_credentials_deletion")]
        public bool Is_credentials_deletion { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("credentials_id")]
        public string Credentials_id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("device")]
        [System.ComponentModel.DataAnnotations.Required]
        public PushNotificationDevice Device { get; set; } = new PushNotificationDevice();

        [System.Text.Json.Serialization.JsonPropertyName("identificativo_soggetto")]
        [System.ComponentModel.DataAnnotations.Required]
        public string Identificativo_soggetto { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("user_name")]
        public string User_name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PushNotificationDeviceSync
    {

        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<PushNotificationType>))]
        public PushNotificationType Type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("device")]
        [System.ComponentModel.DataAnnotations.Required]
        public PushNotificationDevice Device { get; set; } = new PushNotificationDevice();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PushNotificationType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Notification")]
        Notification = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"DeviceInfo")]
        DeviceInfo = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"DeviceSync")]
        DeviceSync = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RentriPushNotification
    {

        [System.Text.Json.Serialization.JsonPropertyName("action")]
        public string Action { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("handle")]
        public string Handle { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("otp")]
        public string Otp { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("expires_in")]
        public int? Expires_in { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("credentials_id")]
        public string Credentials_id { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("title")]
        public string Title { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("body")]
        public string Body { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResetPinRequest
    {

        /// <summary>
        /// Token della richiesta di reset.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("token")]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Token { get; set; }

        /// <summary>
        /// Nuovo PIN.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("new_pin")]
        [System.ComponentModel.DataAnnotations.StringLength(6, MinimumLength = 6)]
        public string New_pin { get; set; }

        /// <summary>
        /// Annullamento della procedura.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("abort")]
        public bool Abort { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SignAlgorithms
    {

        /// <summary>
        /// Elenco degli algoritmi di firma supportati dal servizio.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("algos")]
        public System.Collections.Generic.ICollection<string> Algos { get; set; }

        /// <summary>
        /// Elenco degli eventuali parametri di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("algo_params")]
        public System.Collections.Generic.ICollection<string> Algo_params { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SignatureFormats
    {

        /// <summary>
        /// Elenco dei formati di firma supportati dal servizio.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("formats")]
        public System.Collections.Generic.ICollection<string> Formats { get; set; }

        /// <summary>
        /// Elenco delle propriet riguardanti la busta firmata.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("envelope_properties")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<string>> Envelope_properties { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SignatureQualifier
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EU_eIDAS_QES")]
        EU_eIDAS_QES = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"EU_eIDAS_AES")]
        EU_eIDAS_AES = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"EU_eIDAS_AESQC")]
        EU_eIDAS_AESQC = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"EU_eIDAS_QESeal")]
        EU_eIDAS_QESeal = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"EU_eIDAS_AESeal")]
        EU_eIDAS_AESeal = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"EU_eIDAS_AESealQC")]
        EU_eIDAS_AESealQC = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"ZA_ECTA_AES")]
        ZA_ECTA_AES = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"ZA_ECTA_OES")]
        ZA_ECTA_OES = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SignatureRequest
    {

        /// <summary>
        /// Identificativo delle credenziali di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("credentials_id")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(9, MinimumLength = 9)]
        public string Credentials_id { get; set; }

        /// <summary>
        /// SAD (Signature Activation Data).
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sad")]
        [System.ComponentModel.DataAnnotations.Required]
        public string Sad { get; set; }

        /// <summary>
        /// Elenco dei codici hash da firmare in formato base 64. Attualmente  consentito l'invio di un solo codice hash.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("hashes")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.MinLength(1)]
        [System.ComponentModel.DataAnnotations.MaxLength(1)]
        public System.Collections.Generic.ICollection<string> Hashes { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// OID dell'algoritmo utilizzato per calcolare l'hash. Questo parametro deve essere omesso o ignorato se l'algoritmo hash  implicitamente specificato dal parametro SignAlgo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("hash_algo")]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^2\.16\.840\.1\.101\.3\.4\.2\.1$")]
        public string Hash_algo { get; set; }

        /// <summary>
        /// OID dell'algoritmo da utilizzare per la firma. Deve essere uno dei valori consentiti dalle credenziali.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sign_algo")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^1\.2\.840\.10045\.4\.3\.2$")]
        public string Sign_algo { get; set; }

        /// <summary>
        /// I parametri per l'algoritmo di firma, se richiesti dall'algoritmo di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("sign_algo_params")]
        public string Sign_algo_params { get; set; }

        /// <summary>
        /// Dati arbitrari dell'applicazione di firma.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("client_data")]
        public string Client_data { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SignatureResponse
    {

        /// <summary>
        /// Lista delle firme applicate.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("signatures")]
        public System.Collections.Generic.ICollection<string> Signatures { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Stato
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Attivo")]
        Attivo = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Eliminato")]
        Eliminato = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Nuovo")]
        Nuovo = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"Revocato")]
        Revocato = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Scaduto")]
        Scaduto = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"Inattivo")]
        Inattivo = 5,

    }

    /// <summary>
    /// Risposta di stato dell'API
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StatusResponse
    {

        /// <summary>
        /// Stato dell'API&lt;p&gt;Valori ammessi:&lt;ul style="margin:0"&gt;&lt;li&gt;&lt;i&gt;Ok&lt;/i&gt; - API regolarmente funzionante&lt;/li&gt;&lt;li&gt;&lt;i&gt;Warning&lt;/i&gt; - API funzionante, ma con probabili disservizi come indicato nei warning&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("status")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter<StatusResponseEnum>))]
        public StatusResponseEnum Status { get; set; }

        /// <summary>
        /// Eventuali messaggi di warning relativi allo stato dell'API
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("warnings")]
        public System.Collections.Generic.ICollection<string> Warnings { get; set; }

    }

    /// <summary>
    /// Enumerazione dello stato dell'API.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum StatusResponseEnum
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Ok")]
        Ok = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Warning")]
        Warning = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SyncDeviceInfoRequest
    {

        /// <summary>
        /// Codice Fiscale di un Operatore iscritto.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identificativo_soggetto")]
        [System.ComponentModel.DataAnnotations.Required]
        public string Identificativo_soggetto { get; set; }

        /// <summary>
        /// Identificativo del dispositivo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("identifier")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(50, MinimumLength = 1)]
        public string Identifier { get; set; }

        /// <summary>
        /// Nome.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(150, MinimumLength = 1)]
        public string Name { get; set; }

        /// <summary>
        /// Versione del Sistema Operativo.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("os_version")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(14, MinimumLength = 1)]
        public string Os_version { get; set; }

        /// <summary>
        /// URI di callback alla quale verranno inviati in POST i dati delle notifiche RENTRI.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("notification_callback_uri")]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(2000, MinimumLength = 1)]
        public string Notification_callback_uri { get; set; }

        /// <summary>
        /// Dizionario di parametri custom che verranno inviati, tra i dati delle notifiche, all'URI di callback.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("notification_callback_parameters")]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IDictionary<string, string> Notification_callback_parameters { get; set; } = new System.Collections.Generic.Dictionary<string, string>();

        /// <summary>
        /// Informazioni sulla App installata.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("app_info")]
        [System.ComponentModel.DataAnnotations.Required]
        public AppInfo App_info { get; set; } = new AppInfo();

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client;
        private System.IDisposable _response;

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode;
            Headers = headers;
            Stream = stream;
            _client = client;
            _response = response;
        }

        public void Dispose()
        {
            Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }


    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765